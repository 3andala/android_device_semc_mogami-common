diff -rNu a/Android.mk b/Android.mk
--- a/Android.mk	1970-01-01 02:00:00.000000000 +0200
+++ b/Android.mk	2011-12-20 18:29:46.000000000 +0200
@@ -0,0 +1,36 @@
+ifeq ($(BOARD_WLAN_DEVICE),wl12xx_mac80211)
+
+LOCAL_PATH := $(call my-dir)
+WL12XX_LOCAL_PATH := $(LOCAL_PATH)
+include $(CLEAR_VARS)
+
+WL12XX_BUILD_PATH = $(TARGET_OUT_INTERMEDIATES)/WL12XX_OBJ
+KERNEL_PATH = $(abspath $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ)
+
+prep:
+	rsync -r -u $(WL12XX_LOCAL_PATH)/* $(WL12XX_BUILD_PATH)
+
+$(WL12XX_BUILD_PATH)/compat/compat.ko: prep $(PRODUCT_OUT)/kernel.si_
+	(cd $(WL12XX_BUILD_PATH) && make KLIB=$(KERNEL_PATH) KLIB_BUILD=$(KERNEL_PATH) ARCH=arm CROSS_COMPILE=arm-eabi-)
+
+$(WL12XX_BUILD_PATH)/drivers/net/wireless/wl12xx/wl12xx_sdio.ko: $(WL12XX_BUILD_PATH)/drivers/net/wireless/wl12xx/wl12xx.ko
+
+$(WL12XX_BUILD_PATH)/drivers/net/wireless/wl12xx/wl12xx.ko: $(WL12XX_BUILD_PATH)/net/mac80211/mac80211.ko
+
+$(WL12XX_BUILD_PATH)/net/mac80211/mac80211.ko: $(WL12XX_BUILD_PATH)/net/wireless/cfg80211.ko
+
+$(WL12XX_BUILD_PATH)/net/wireless/cfg80211.ko: $(WL12XX_BUILD_PATH)/compat/compat.ko
+
+files := drivers/net/wireless/wl12xx/wl12xx_sdio.ko drivers/net/wireless/wl12xx/wl12xx.ko compat/compat.ko net/wireless/cfg80211.ko net/mac80211/mac80211.ko
+
+copy_from := $(addprefix $(WL12XX_BUILD_PATH)/,$(files))
+copy_to := $(addprefix $(TARGET_OUT)/lib/modules/,$(files))
+
+$(TARGET_OUT)/lib/modules/%.ko : $(WL12XX_BUILD_PATH)/%.ko | $(ACP)
+	$(transform-prebuilt-to-target)
+
+ALL_PREBUILT += $(copy_to)
+
+endif
+
+
diff -rNu a/code-metrics.txt b/code-metrics.txt
--- a/code-metrics.txt	2012-03-23 12:18:26.000000000 +0200
+++ b/code-metrics.txt	2011-12-20 18:29:46.000000000 +0200
@@ -1,14 +1,14 @@
 
 [36mcompat-wireless code metrics[00m
 
-[35m    875694[00m - Total upstream lines of code being pulled
+[35m    875475[00m - Total upstream lines of code being pulled
 [01;32m      2210[00m - backport code changes
 [01;32m      1932[00m - backport code additions
 [01;32m       278[00m - backport code deletions
-[01;32m      8559[00m - backport from compat module
-[01;32m     10769[00m - total backport code
-[31m    1.2298[00m - % of code consists of backport work
+[01;32m      8071[00m - backport from compat module
+[01;32m     10281[00m - total backport code
+[31m    1.1743[00m - % of code consists of backport work
 
-Base tree: [01;32mwl12xx[00m
+Base tree: [01;32mwl12xx.git[00m
 Base tree version: [35mv2.6.39-1250-g40f5df0[00m
-compat-wireless release: [01;33m[00m
+compat-wireless release: [01;33mcompat-wireless-2011-05-19-2-gfa00a5a[00m
diff -rNu a/compat/compat-2.6.35.c b/compat/compat-2.6.35.c
--- a/compat/compat-2.6.35.c	2012-03-23 12:18:25.000000000 +0200
+++ b/compat/compat-2.6.35.c	2011-12-20 18:29:46.000000000 +0200
@@ -11,6 +11,7 @@
 #include <linux/compat.h>
 #include <linux/ctype.h>
 
+#if 0
 /**
  * hex_to_bin - convert a hex digit to its real value
  * @ch: ascii character represents hex digit
@@ -28,6 +29,7 @@
 	return -1;
 }
 EXPORT_SYMBOL(hex_to_bin);
+#endif
 
 /**
  * noop_llseek - No Operation Performed llseek implementation
diff -rNu a/compat/compat-2.6.37.c b/compat/compat-2.6.37.c
--- a/compat/compat-2.6.37.c	2012-03-23 12:18:25.000000000 +0200
+++ b/compat/compat-2.6.37.c	2011-12-20 18:29:46.000000000 +0200
@@ -158,7 +158,7 @@
 #undef led_brightness_set
 #undef led_classdev_unregister
 
-static DEFINE_SPINLOCK(led_lock);
+spinlock_t led_lock;
 static LIST_HEAD(led_timers);
 
 struct led_timer {
diff -rNu a/compat/compat-3.0.c b/compat/compat-3.0.c
--- a/compat/compat-3.0.c	2012-03-23 12:18:25.000000000 +0200
+++ b/compat/compat-3.0.c	1970-01-01 02:00:00.000000000 +0200
@@ -1,62 +0,0 @@
-/*
- * Copyright 2011    Hauke Mehrtens <hauke@hauke-m.de>
- * Copyright 2011    Alexey Dobriyan <adobriyan@gmail.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * Compatibility file for Linux wireless for kernels 3.0.
- */
-
-#include <linux/compat.h>
-#include <linux/if_ether.h>
-
-int mac_pton(const char *s, u8 *mac)
-{
-	int i;
-
-	/* XX:XX:XX:XX:XX:XX */
-	if (strlen(s) < 3 * ETH_ALEN - 1)
-		return 0;
-
-	/* Don't dirty result unless string is valid MAC. */
-	for (i = 0; i < ETH_ALEN; i++) {
-		if (!strchr("0123456789abcdefABCDEF", s[i * 3]))
-			return 0;
-		if (!strchr("0123456789abcdefABCDEF", s[i * 3 + 1]))
-			return 0;
-		if (i != ETH_ALEN - 1 && s[i * 3 + 2] != ':')
-			return 0;
-	}
-	for (i = 0; i < ETH_ALEN; i++) {
-		mac[i] = (hex_to_bin(s[i * 3]) << 4) | hex_to_bin(s[i * 3 + 1]);
-	}
-	return 1;
-}
-EXPORT_SYMBOL(mac_pton);
-
-#define kstrto_from_user(f, g, type)					\
-int f(const char __user *s, size_t count, unsigned int base, type *res)	\
-{									\
-	/* sign, base 2 representation, newline, terminator */		\
-	char buf[1 + sizeof(type) * 8 + 1 + 1];				\
-									\
-	count = min(count, sizeof(buf) - 1);				\
-	if (copy_from_user(buf, s, count))				\
-		return -EFAULT;						\
-	buf[count] = '\0';						\
-	return g(buf, base, res);					\
-}									\
-EXPORT_SYMBOL(f)
-
-kstrto_from_user(kstrtoull_from_user,	kstrtoull,	unsigned long long);
-kstrto_from_user(kstrtoll_from_user,	kstrtoll,	long long);
-kstrto_from_user(kstrtoul_from_user,	kstrtoul,	unsigned long);
-kstrto_from_user(kstrtol_from_user,	kstrtol,	long);
-kstrto_from_user(kstrtouint_from_user,	kstrtouint,	unsigned int);
-kstrto_from_user(kstrtoint_from_user,	kstrtoint,	int);
-kstrto_from_user(kstrtou16_from_user,	kstrtou16,	u16);
-kstrto_from_user(kstrtos16_from_user,	kstrtos16,	s16);
-kstrto_from_user(kstrtou8_from_user,	kstrtou8,	u8);
-kstrto_from_user(kstrtos8_from_user,	kstrtos8,	s8);
diff -rNu a/compat/compat_firmware_class.c b/compat/compat_firmware_class.c
--- a/compat/compat_firmware_class.c	2012-03-23 12:18:25.000000000 +0200
+++ b/compat/compat_firmware_class.c	2011-12-20 18:29:46.000000000 +0200
@@ -1,3 +1,4 @@
+#if 0
 /*
  * firmware_class.c - Multi purpose firmware loading support
  *
@@ -745,3 +746,5 @@
 EXPORT_SYMBOL(release_firmware);
 EXPORT_SYMBOL(request_firmware);
 EXPORT_SYMBOL(request_firmware_nowait);
+#endif
+
diff -rNu a/compat/cordic.c b/compat/cordic.c
--- a/compat/cordic.c	2012-03-23 12:18:25.000000000 +0200
+++ b/compat/cordic.c	1970-01-01 02:00:00.000000000 +0200
@@ -1,101 +0,0 @@
-/*
- * Copyright (c) 2011 Broadcom Corporation
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-#include <linux/module.h>
-#include <linux/cordic.h>
-
-#define CORDIC_ANGLE_GEN	39797
-#define CORDIC_PRECISION_SHIFT	16
-#define	CORDIC_NUM_ITER		(CORDIC_PRECISION_SHIFT + 2)
-
-#define	FIXED(X)	((s32)((X) << CORDIC_PRECISION_SHIFT))
-#define	FLOAT(X)	(((X) >= 0) \
-		? ((((X) >> (CORDIC_PRECISION_SHIFT - 1)) + 1) >> 1) \
-		: -((((-(X)) >> (CORDIC_PRECISION_SHIFT - 1)) + 1) >> 1))
-
-static const s32 arctan_table[] = {
-	2949120,
-	1740967,
-	919879,
-	466945,
-	234379,
-	117304,
-	58666,
-	29335,
-	14668,
-	7334,
-	3667,
-	1833,
-	917,
-	458,
-	229,
-	115,
-	57,
-	29
-};
-
-/*
- * cordic_calc_iq() - calculates the i/q coordinate for given angle
- *
- * theta: angle in degrees for which i/q coordinate is to be calculated
- * coord: function output parameter holding the i/q coordinate
- */
-struct cordic_iq cordic_calc_iq(s32 theta)
-{
-	struct cordic_iq coord;
-	s32 angle, valtmp;
-	unsigned iter;
-	int signx = 1;
-	int signtheta;
-
-	coord.i = CORDIC_ANGLE_GEN;
-	coord.q = 0;
-	angle = 0;
-
-	theta = FIXED(theta);
-	signtheta = (theta < 0) ? -1 : 1;
-	theta = ((theta + FIXED(180) * signtheta) % FIXED(360)) -
-		FIXED(180) * signtheta;
-
-	if (FLOAT(theta) > 90) {
-		theta -= FIXED(180);
-		signx = -1;
-	} else if (FLOAT(theta) < -90) {
-		theta += FIXED(180);
-		signx = -1;
-	}
-
-	for (iter = 0; iter < CORDIC_NUM_ITER; iter++) {
-		if (theta > angle) {
-			valtmp = coord.i - (coord.q >> iter);
-			coord.q += (coord.i >> iter);
-			angle += arctan_table[iter];
-		} else {
-			valtmp = coord.i + (coord.q >> iter);
-			coord.q -= (coord.i >> iter);
-			angle -= arctan_table[iter];
-		}
-		coord.i = valtmp;
-	}
-
-	coord.i *= signx;
-	coord.q *= signx;
-	return coord;
-}
-EXPORT_SYMBOL(cordic_calc_iq);
-
-MODULE_DESCRIPTION("Cordic functions");
-MODULE_AUTHOR("Broadcom Corporation");
-MODULE_LICENSE("Dual BSD/GPL");
diff -rNu a/compat/crc8.c b/compat/crc8.c
--- a/compat/crc8.c	2012-03-23 12:18:25.000000000 +0200
+++ b/compat/crc8.c	1970-01-01 02:00:00.000000000 +0200
@@ -1,86 +0,0 @@
-/*
- * Copyright (c) 2011 Broadcom Corporation
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#define pr_fmt(fmt)		KBUILD_MODNAME ": " fmt
-
-#include <linux/module.h>
-#include <linux/crc8.h>
-#include <linux/printk.h>
-
-/*
- * crc8_populate_msb - fill crc table for given polynomial in reverse bit order.
- *
- * table:	table to be filled.
- * polynomial:	polynomial for which table is to be filled.
- */
-void crc8_populate_msb(u8 table[CRC8_TABLE_SIZE], u8 polynomial)
-{
-	int i, j;
-	const u8 msbit = 0x80;
-	u8 t = msbit;
-
-	table[0] = 0;
-
-	for (i = 1; i < CRC8_TABLE_SIZE; i *= 2) {
-		t = (t << 1) ^ (t & msbit ? polynomial : 0);
-		for (j = 0; j < i; j++)
-			table[i+j] = table[j] ^ t;
-	}
-}
-EXPORT_SYMBOL(crc8_populate_msb);
-
-/*
- * crc8_populate_lsb - fill crc table for given polynomial in regular bit order.
- *
- * table:	table to be filled.
- * polynomial:	polynomial for which table is to be filled.
- */
-void crc8_populate_lsb(u8 table[CRC8_TABLE_SIZE], u8 polynomial)
-{
-	int i, j;
-	u8 t = 1;
-
-	table[0] = 0;
-
-	for (i = (CRC8_TABLE_SIZE >> 1); i; i >>= 1) {
-		t = (t >> 1) ^ (t & 1 ? polynomial : 0);
-		for (j = 0; j < CRC8_TABLE_SIZE; j += 2*i)
-			table[i+j] = table[j] ^ t;
-	}
-}
-EXPORT_SYMBOL(crc8_populate_lsb);
-
-/*
- * crc8 - calculate a crc8 over the given input data.
- *
- * table: crc table used for calculation.
- * pdata: pointer to data buffer.
- * nbytes: number of bytes in data buffer.
- * crc:	previous returned crc8 value.
- */
-u8 crc8(const u8 table[CRC8_TABLE_SIZE], u8 *pdata, size_t nbytes, u8 crc)
-{
-	/* loop over the buffer data */
-	while (nbytes-- > 0)
-		crc = table[(crc ^ *pdata++) & 0xff];
-
-	return crc;
-}
-EXPORT_SYMBOL(crc8);
-
-MODULE_DESCRIPTION("CRC8 (by Williams, Ross N.) function");
-MODULE_AUTHOR("Broadcom Corporation");
-MODULE_LICENSE("Dual BSD/GPL");
diff -rNu a/compat/Makefile b/compat/Makefile
--- a/compat/Makefile	2012-03-23 12:18:25.000000000 +0200
+++ b/compat/Makefile	2011-12-20 18:29:46.000000000 +0200
@@ -6,35 +6,31 @@
 compat-y += main.o
 
 # Compat kernel compatibility code
-compat-$(CONFIG_COMPAT_KERNEL_2_6_14) += compat-2.6.14.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_18) += compat-2.6.18.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_19) += compat-2.6.19.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_21) += compat-2.6.21.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_22) += compat-2.6.22.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_23) += compat-2.6.23.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_24) += compat-2.6.24.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_25) += \
+compat-$(CONFIG_COMPAT_KERNEL_14) += compat-2.6.14.o
+compat-$(CONFIG_COMPAT_KERNEL_18) += compat-2.6.18.o
+compat-$(CONFIG_COMPAT_KERNEL_19) += compat-2.6.19.o
+compat-$(CONFIG_COMPAT_KERNEL_21) += compat-2.6.21.o
+compat-$(CONFIG_COMPAT_KERNEL_22) += compat-2.6.22.o
+compat-$(CONFIG_COMPAT_KERNEL_23) += compat-2.6.23.o
+compat-$(CONFIG_COMPAT_KERNEL_24) += compat-2.6.24.o
+compat-$(CONFIG_COMPAT_KERNEL_25) += \
 	compat-2.6.25.o \
 	pm_qos_params.o
 
-compat-$(CONFIG_COMPAT_KERNEL_2_6_26) += compat-2.6.26.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_27) += compat-2.6.27.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_28) += compat-2.6.28.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_29) += compat-2.6.29.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_32) += compat-2.6.32.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_33) += compat-2.6.33.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_35) += compat-2.6.35.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_36) += \
+compat-$(CONFIG_COMPAT_KERNEL_26) += compat-2.6.26.o
+compat-$(CONFIG_COMPAT_KERNEL_27) += compat-2.6.27.o
+compat-$(CONFIG_COMPAT_KERNEL_28) += compat-2.6.28.o
+compat-$(CONFIG_COMPAT_KERNEL_29) += compat-2.6.29.o
+compat-$(CONFIG_COMPAT_KERNEL_32) += compat-2.6.32.o
+compat-$(CONFIG_COMPAT_KERNEL_33) += compat-2.6.33.o
+compat-$(CONFIG_COMPAT_KERNEL_35) += compat-2.6.35.o
+compat-$(CONFIG_COMPAT_KERNEL_36) += \
 	compat-2.6.36.o \
 	kfifo.o
 
-compat-$(CONFIG_COMPAT_KERNEL_2_6_37) += compat-2.6.37.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_38) += compat-2.6.38.o
-compat-$(CONFIG_COMPAT_KERNEL_2_6_39) += \
+compat-$(CONFIG_COMPAT_KERNEL_37) += compat-2.6.37.o
+compat-$(CONFIG_COMPAT_KERNEL_38) += compat-2.6.38.o
+compat-$(CONFIG_COMPAT_KERNEL_39) += \
 	compat-2.6.39.o \
 	kstrtox.o
-compat-$(CONFIG_COMPAT_KERNEL_3_0) += compat-3.0.o
-compat-$(CONFIG_COMPAT_KERNEL_3_1) += \
-	cordic.o \
-	crc8.o
 
diff -rNu a/compat/modules.order b/compat/modules.order
--- a/compat/modules.order	1970-01-01 02:00:00.000000000 +0200
+++ b/compat/modules.order	2011-12-20 18:29:46.000000000 +0200
@@ -0,0 +1,2 @@
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/compat/compat.ko
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/compat/compat_firmware_class.ko
diff -rNu a/compat_base_tree b/compat_base_tree
--- a/compat_base_tree	2012-03-23 12:18:26.000000000 +0200
+++ b/compat_base_tree	2011-12-20 18:29:46.000000000 +0200
@@ -1 +1 @@
-wl12xx
+wl12xx.git
diff -rNu a/compat_version b/compat_version
--- a/compat_version	2012-03-23 12:18:26.000000000 +0200
+++ b/compat_version	2011-12-20 18:29:46.000000000 +0200
@@ -1 +1 @@
-
+compat-wireless-2011-05-19-2-gfa00a5a
diff -rNu a/drivers/net/wireless/modules.order b/drivers/net/wireless/modules.order
--- a/drivers/net/wireless/modules.order	1970-01-01 02:00:00.000000000 +0200
+++ b/drivers/net/wireless/modules.order	2011-12-20 18:29:47.000000000 +0200
@@ -0,0 +1,6 @@
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/drivers/net/wireless/wl12xx/wl12xx.ko
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/drivers/net/wireless/wl12xx/wl12xx_spi.ko
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/drivers/net/wireless/wl12xx/wl12xx_sdio.ko
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/drivers/net/wireless/wl1251/wl1251.ko
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/drivers/net/wireless/wl1251/wl1251_spi.ko
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/drivers/net/wireless/wl1251/wl1251_sdio.ko
diff -rNu a/drivers/net/wireless/wl1251/modules.order b/drivers/net/wireless/wl1251/modules.order
--- a/drivers/net/wireless/wl1251/modules.order	1970-01-01 02:00:00.000000000 +0200
+++ b/drivers/net/wireless/wl1251/modules.order	2011-12-20 18:29:47.000000000 +0200
@@ -0,0 +1,3 @@
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/drivers/net/wireless/wl1251/wl1251.ko
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/drivers/net/wireless/wl1251/wl1251_spi.ko
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/drivers/net/wireless/wl1251/wl1251_sdio.ko
diff -rNu a/drivers/net/wireless/wl12xx/cmd.c b/drivers/net/wireless/wl12xx/cmd.c
--- a/drivers/net/wireless/wl12xx/cmd.c	2012-03-23 12:18:25.000000000 +0200
+++ b/drivers/net/wireless/wl12xx/cmd.c	2011-12-20 18:29:47.000000000 +0200
@@ -1143,6 +1143,7 @@
 {
 	struct sk_buff *skb;
 	int ret;
+	u32 rate;
 
 	skb = ieee80211_probereq_get(wl->hw, wl->vif, ssid, ssid_len,
 				     ie, ie_len);
@@ -1153,14 +1154,13 @@
 
 	wl1271_dump(DEBUG_SCAN, "PROBE REQ: ", skb->data, skb->len);
 
+	rate = wl1271_tx_min_rate_get(wl, wl->bitrate_masks[band]);
 	if (band == IEEE80211_BAND_2GHZ)
 		ret = wl1271_cmd_template_set(wl, CMD_TEMPL_CFG_PROBE_REQ_2_4,
-					      skb->data, skb->len, 0,
-					      wl->conf.tx.basic_rate);
+					      skb->data, skb->len, 0, rate);
 	else
 		ret = wl1271_cmd_template_set(wl, CMD_TEMPL_CFG_PROBE_REQ_5,
-					      skb->data, skb->len, 0,
-					      wl->conf.tx.basic_rate_5);
+					      skb->data, skb->len, 0, rate);
 
 out:
 	dev_kfree_skb(skb);
@@ -1171,6 +1171,7 @@
 					      struct sk_buff *skb)
 {
 	int ret;
+	u32 rate;
 
 	if (!skb)
 		skb = ieee80211_ap_probereq_get(wl->hw, wl->vif);
@@ -1179,14 +1180,13 @@
 
 	wl1271_dump(DEBUG_SCAN, "AP PROBE REQ: ", skb->data, skb->len);
 
+	rate = wl1271_tx_min_rate_get(wl, wl->bitrate_masks[wl->band]);
 	if (wl->band == IEEE80211_BAND_2GHZ)
 		ret = wl1271_cmd_template_set(wl, CMD_TEMPL_CFG_PROBE_REQ_2_4,
-					      skb->data, skb->len, 0,
-					      wl->conf.tx.basic_rate);
+					      skb->data, skb->len, 0, rate);
 	else
 		ret = wl1271_cmd_template_set(wl, CMD_TEMPL_CFG_PROBE_REQ_5,
-					      skb->data, skb->len, 0,
-					      wl->conf.tx.basic_rate_5);
+					      skb->data, skb->len, 0, rate);
 
 	if (ret < 0)
 		wl1271_error("Unable to set ap probe request template.");
@@ -1511,7 +1511,8 @@
 		sta_rates |= sta->ht_cap.mcs.rx_mask[0] << HW_HT_RATES_OFFSET;
 
 	cmd->supported_rates =
-		cpu_to_le32(wl1271_tx_enabled_rates_get(wl, sta_rates));
+		cpu_to_le32(wl1271_tx_enabled_rates_get(wl, sta_rates,
+			    wl->band));
 
 	wl1271_debug(DEBUG_CMD, "new sta rates=0x%x queues=0x%x",
 		     cmd->supported_rates, sta->uapsd_queues);
diff -rNu a/drivers/net/wireless/wl12xx/init.c b/drivers/net/wireless/wl12xx/init.c
--- a/drivers/net/wireless/wl12xx/init.c	2012-03-23 12:18:25.000000000 +0200
+++ b/drivers/net/wireless/wl12xx/init.c	2011-12-20 18:29:47.000000000 +0200
@@ -110,6 +110,7 @@
 {
 	struct wl12xx_disconn_template *tmpl;
 	int ret;
+	u32 rate;
 
 	tmpl = kzalloc(sizeof(*tmpl), GFP_KERNEL);
 	if (!tmpl) {
@@ -120,9 +121,9 @@
 	tmpl->header.frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT |
 					     IEEE80211_STYPE_DEAUTH);
 
+	rate = wl1271_tx_min_rate_get(wl, wl->basic_rate_set);
 	ret = wl1271_cmd_template_set(wl, CMD_TEMPL_DEAUTH_AP,
-				      tmpl, sizeof(*tmpl), 0,
-				      wl1271_tx_min_rate_get(wl));
+				      tmpl, sizeof(*tmpl), 0, rate);
 
 out:
 	kfree(tmpl);
@@ -133,6 +134,7 @@
 {
 	struct ieee80211_hdr_3addr *nullfunc;
 	int ret;
+	u32 rate;
 
 	nullfunc = kzalloc(sizeof(*nullfunc), GFP_KERNEL);
 	if (!nullfunc) {
@@ -149,9 +151,9 @@
 	memcpy(nullfunc->addr2, wl->mac_addr, ETH_ALEN);
 	memcpy(nullfunc->addr3, wl->mac_addr, ETH_ALEN);
 
+	rate = wl1271_tx_min_rate_get(wl, wl->basic_rate_set);
 	ret = wl1271_cmd_template_set(wl, CMD_TEMPL_NULL_DATA, nullfunc,
-				      sizeof(*nullfunc), 0,
-				      wl1271_tx_min_rate_get(wl));
+				      sizeof(*nullfunc), 0, rate);
 
 out:
 	kfree(nullfunc);
@@ -162,6 +164,7 @@
 {
 	struct ieee80211_qos_hdr *qosnull;
 	int ret;
+	u32 rate;
 
 	qosnull = kzalloc(sizeof(*qosnull), GFP_KERNEL);
 	if (!qosnull) {
@@ -178,9 +181,9 @@
 	memcpy(qosnull->addr2, wl->mac_addr, ETH_ALEN);
 	memcpy(qosnull->addr3, wl->mac_addr, ETH_ALEN);
 
+	rate = wl1271_tx_min_rate_get(wl, wl->basic_rate_set);
 	ret = wl1271_cmd_template_set(wl, CMD_TEMPL_QOS_NULL_DATA, qosnull,
-				      sizeof(*qosnull), 0,
-				      wl1271_tx_min_rate_get(wl));
+				      sizeof(*qosnull), 0, rate);
 
 out:
 	kfree(qosnull);
@@ -502,7 +505,7 @@
 		return ret;
 
 	/* use the min basic rate for AP broadcast/multicast */
-	rc.enabled_rates = wl1271_tx_min_rate_get(wl);
+	rc.enabled_rates = wl1271_tx_min_rate_get(wl, wl->basic_rate_set);
 	rc.short_retry_limit = 10;
 	rc.long_retry_limit = 10;
 	rc.aflags = 0;
diff -rNu a/drivers/net/wireless/wl12xx/main.c b/drivers/net/wireless/wl12xx/main.c
--- a/drivers/net/wireless/wl12xx/main.c	2012-03-23 12:18:25.000000000 +0200
+++ b/drivers/net/wireless/wl12xx/main.c	2011-12-20 18:29:47.000000000 +0200
@@ -2108,8 +2108,11 @@
 	wl->time_offset = 0;
 	wl->session_counter = 0;
 	wl->rate_set = CONF_TX_RATE_MASK_BASIC;
+	wl->bitrate_masks[IEEE80211_BAND_2GHZ] = wl->conf.tx.basic_rate;
+	wl->bitrate_masks[IEEE80211_BAND_5GHZ] = wl->conf.tx.basic_rate_5;
 	wl->vif = NULL;
 	wl->filters = 0;
+	wl->tx_spare_blocks = TX_HW_BLOCK_SPARE_DEFAULT;
 	wl1271_free_ap_keys(wl);
 	memset(wl->ap_hlid_map, 0, sizeof(wl->ap_hlid_map));
 	wl->ap_fw_ps_map = 0;
@@ -2285,14 +2288,8 @@
 
 static void wl1271_set_band_rate(struct wl1271 *wl)
 {
-	if (wl->band == IEEE80211_BAND_2GHZ) {
-		wl->basic_rate_set = wl->conf.tx.basic_rate;
-		wl->rate_set = wl->conf.tx.basic_rate;
-	} else {
-		wl->basic_rate_set = wl->conf.tx.basic_rate_5;
-		wl->rate_set = wl->conf.tx.basic_rate_5;
-	}
-
+	wl->basic_rate_set = wl->bitrate_masks[wl->band];
+	wl->rate_set = wl->basic_rate_set;
 }
 
 static int wl1271_sta_handle_idle(struct wl1271 *wl, bool idle)
@@ -2309,7 +2306,7 @@
 			if (ret < 0)
 				goto out;
 		}
-		wl->rate_set = wl1271_tx_min_rate_get(wl);
+		wl->rate_set = wl1271_tx_min_rate_get(wl, wl->basic_rate_set);
 		ret = wl1271_acx_sta_rate_policies(wl);
 		if (ret < 0)
 			goto out;
@@ -2406,7 +2403,8 @@
 			if (!test_bit(WL1271_FLAG_STA_ASSOCIATED, &wl->flags))
 				wl1271_set_band_rate(wl);
 
-			wl->basic_rate = wl1271_tx_min_rate_get(wl);
+			wl->basic_rate =
+				wl1271_tx_min_rate_get(wl, wl->basic_rate_set);
 			ret = wl1271_acx_sta_rate_policies(wl);
 			if (ret < 0)
 				wl1271_warning("rate policy for channel "
@@ -2774,6 +2772,17 @@
 			0xff, 0xff, 0xff, 0xff, 0xff, 0xff
 		};
 
+		/*
+		 * A STA set to GEM cipher requires 2 tx spare blocks.
+		 * Return to default value when GEM cipher key is removed
+		 */
+		if (key_type == KEY_GEM) {
+			if (action == KEY_ADD_OR_REPLACE)
+				wl->tx_spare_blocks = 2;
+			else if (action == KEY_REMOVE)
+				wl->tx_spare_blocks = TX_HW_BLOCK_SPARE_DEFAULT;
+		}
+
 		addr = sta ? sta->addr : bcast_addr;
 
 		if (is_zero_ether_addr(addr)) {
@@ -3173,10 +3182,32 @@
 	skb_trim(skb, skb->len - len);
 }
 
-static int wl1271_ap_set_probe_resp_tmpl(struct wl1271 *wl,
-					 u8 *probe_rsp_data,
-					 size_t probe_rsp_len,
-					 u32 rates)
+static int wl1271_ap_set_probe_resp_tmpl(struct wl1271 *wl, u32 rates)
+{
+	struct sk_buff *skb;
+	int ret;
+
+	skb = ieee80211_proberesp_get(wl->hw, wl->vif);
+	if (!skb)
+		return -EINVAL;
+
+	ret = wl1271_cmd_template_set(wl,
+				      CMD_TEMPL_AP_PROBE_RESPONSE,
+				      skb->data,
+				      skb->len, 0,
+				      rates);
+
+	if (!ret)
+		set_bit(WL1271_FLAG_PROBE_RESP_SET, &wl->flags);
+
+	dev_kfree_skb(skb);
+	return ret;
+}
+
+static int wl1271_ap_set_probe_resp_tmpl_legacy(struct wl1271 *wl,
+					     u8 *probe_rsp_data,
+					     size_t probe_rsp_len,
+					     u32 rates)
 {
 	struct ieee80211_bss_conf *bss_conf = &wl->vif->bss_conf;
 	u8 probe_rsp_templ[WL1271_CMD_TEMPL_MAX_SIZE];
@@ -3283,15 +3314,25 @@
 		wl->beacon_int = bss_conf->beacon_int;
 	}
 
+	if ((changed & BSS_CHANGED_AP_PROBE_RESP) && is_ap) {
+		ret = wl1271_ap_set_probe_resp_tmpl(wl,
+			wl1271_tx_min_rate_get(wl, wl->basic_rate_set));
+		if (ret < 0)
+			goto out;
+	}
+
 	if ((changed & BSS_CHANGED_BEACON)) {
 		struct ieee80211_hdr *hdr;
+		u32 min_rate;
 		int ieoffset = offsetof(struct ieee80211_mgmt,
 					u.beacon.variable);
 		struct sk_buff *beacon = ieee80211_beacon_get(wl->hw, vif);
 		u16 tmpl_id;
 
-		if (!beacon)
+		if (!beacon) {
+			ret = -EINVAL;
 			goto out;
+		}
 
 		wl1271_debug(DEBUG_MASTER, "beacon updated");
 
@@ -3300,17 +3341,25 @@
 			dev_kfree_skb(beacon);
 			goto out;
 		}
+		min_rate = wl1271_tx_min_rate_get(wl, wl->basic_rate_set);
 		tmpl_id = is_ap ? CMD_TEMPL_AP_BEACON :
 				  CMD_TEMPL_BEACON;
 		ret = wl1271_cmd_template_set(wl, tmpl_id,
 					      beacon->data,
 					      beacon->len, 0,
-					      wl1271_tx_min_rate_get(wl));
+					      min_rate);
 		if (ret < 0) {
 			dev_kfree_skb(beacon);
 			goto out;
 		}
 
+		/*
+		 * In case we already have a probe-resp beacon set explicitly
+		 * by usermode, don't use the beacon data.
+		 */
+		if (test_bit(WL1271_FLAG_PROBE_RESP_SET, &wl->flags))
+			goto end_bcn;
+
 		/* remove TIM ie from probe response */
 		wl1271_remove_ie(beacon, WLAN_EID_TIM, ieoffset);
 
@@ -3328,22 +3377,25 @@
 		hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
 						 IEEE80211_STYPE_PROBE_RESP);
 		if (is_ap)
-			ret = wl1271_ap_set_probe_resp_tmpl(wl,
+			ret = wl1271_ap_set_probe_resp_tmpl_legacy(wl,
 						beacon->data,
 						beacon->len,
-						wl1271_tx_min_rate_get(wl));
+						min_rate);
 		else
 			ret = wl1271_cmd_template_set(wl,
 						CMD_TEMPL_PROBE_RESPONSE,
 						beacon->data,
 						beacon->len, 0,
-						wl1271_tx_min_rate_get(wl));
+						min_rate);
+end_bcn:
 		dev_kfree_skb(beacon);
 		if (ret < 0)
 			goto out;
 	}
 
 out:
+	if (ret != 0)
+		wl1271_error("beacon info change failed: %d", ret);
 	return ret;
 }
 
@@ -3441,18 +3493,10 @@
 	if ((changed & BSS_CHANGED_BASIC_RATES)) {
 		u32 rates = bss_conf->basic_rates;
 
-		wl->basic_rate_set = wl1271_tx_enabled_rates_get(wl, rates);
-		/*
-		 * TODO: this is a temporary workaround. we should implement
-		 * some set_bitrate_mask() callback instead.
-		 */
-		if (wl->p2p)
-			wl->basic_rate_set &= ~(CONF_HW_BIT_RATE_1MBPS |
-						CONF_HW_BIT_RATE_2MBPS |
-						CONF_HW_BIT_RATE_5_5MBPS |
-						CONF_HW_BIT_RATE_11MBPS);
-
-		wl->basic_rate = wl1271_tx_min_rate_get(wl);
+		wl->basic_rate_set = wl1271_tx_enabled_rates_get(wl, rates,
+								 wl->band);
+		wl->basic_rate = wl1271_tx_min_rate_get(wl,
+							wl->basic_rate_set);
 
 		ret = wl1271_init_ap_rates(wl);
 		if (ret < 0) {
@@ -3486,6 +3530,8 @@
 					goto out;
 
 				clear_bit(WL1271_FLAG_AP_STARTED, &wl->flags);
+				clear_bit(WL1271_FLAG_PROBE_RESP_SET,
+					    &wl->flags);
 				wl1271_debug(DEBUG_AP, "stopped AP");
 			}
 		}
@@ -3631,12 +3677,15 @@
 			 * to use with control frames.
 			 */
 			rates = bss_conf->basic_rates;
-			wl->basic_rate_set = wl1271_tx_enabled_rates_get(wl,
-									 rates);
-			wl->basic_rate = wl1271_tx_min_rate_get(wl);
+			wl->basic_rate_set =
+				wl1271_tx_enabled_rates_get(wl, rates,
+							    wl->band);
+			wl->basic_rate =
+				wl1271_tx_min_rate_get(wl, wl->basic_rate_set);
 			if (sta_rate_set)
 				wl->rate_set = wl1271_tx_enabled_rates_get(wl,
-								sta_rate_set);
+								sta_rate_set,
+								wl->band);
 			ret = wl1271_acx_sta_rate_policies(wl);
 			if (ret < 0)
 				goto out;
@@ -3683,7 +3732,8 @@
 
 			/* revert back to minimum rates for the current band */
 			wl1271_set_band_rate(wl);
-			wl->basic_rate = wl1271_tx_min_rate_get(wl);
+			wl->basic_rate =
+				wl1271_tx_min_rate_get(wl, wl->basic_rate_set);
 			ret = wl1271_acx_sta_rate_policies(wl);
 			if (ret < 0)
 				goto out;
@@ -3734,9 +3784,11 @@
 
 		if (bss_conf->ibss_joined) {
 			u32 rates = bss_conf->basic_rates;
-			wl->basic_rate_set = wl1271_tx_enabled_rates_get(wl,
-									 rates);
-			wl->basic_rate = wl1271_tx_min_rate_get(wl);
+			wl->basic_rate_set =
+				wl1271_tx_enabled_rates_get(wl, rates,
+							    wl->band);
+			wl->basic_rate =
+				wl1271_tx_min_rate_get(wl, wl->basic_rate_set);
 
 			/* by default, use 11b rates */
 			wl->rate_set = CONF_TX_IBSS_DEFAULT_RATES;
@@ -4310,6 +4362,29 @@
 	mutex_unlock(&wl->mutex);
 }
 
+static int wl12xx_set_bitrate_mask(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif,
+				   const struct cfg80211_bitrate_mask *mask)
+{
+	struct wl1271 *wl = hw->priv;
+	int i;
+
+	wl1271_debug(DEBUG_MAC80211, "mac80211 set_bitrate_mask 0x%x 0x%x",
+		mask->control[NL80211_BAND_2GHZ].legacy,
+		mask->control[NL80211_BAND_5GHZ].legacy);
+
+	mutex_lock(&wl->mutex);
+
+	for (i = 0; i < IEEE80211_NUM_BANDS; i++)
+		wl->bitrate_masks[i] =
+			wl1271_tx_enabled_rates_get(wl,
+						    mask->control[i].legacy,
+						    i);
+	mutex_unlock(&wl->mutex);
+
+	return 0;
+}
+
 static bool wl1271_tx_frames_pending(struct ieee80211_hw *hw)
 {
 	struct wl1271 *wl = hw->priv;
@@ -4590,6 +4665,7 @@
 	.ampdu_action = wl1271_op_ampdu_action,
 	.tx_frames_pending = wl1271_tx_frames_pending,
 	.channel_switch = wl12xx_op_channel_switch,
+	.set_bitrate_mask = wl12xx_set_bitrate_mask,
 	CFG80211_TESTMODE_CMD(wl1271_tm_cmd)
 };
 
@@ -4696,7 +4772,7 @@
 static DEVICE_ATTR(hw_pg_ver, S_IRUGO,
 		   wl1271_sysfs_show_hw_pg_ver, NULL);
 
-static ssize_t wl1271_sysfs_read_fwlog(struct file *filp, struct kobject *kobj,
+static ssize_t wl1271_sysfs_read_fwlog(struct kobject *kobj,
 				       struct bin_attribute *bin_attr,
 				       char *buffer, loff_t pos, size_t count)
 {
@@ -4990,6 +5066,7 @@
 	wl->tx_security_seq = 0;
 	wl->tx_security_last_seq_lsb = 0;
 	wl->active_sta_count = 0;
+	wl->tx_spare_blocks = TX_HW_BLOCK_SPARE_DEFAULT;
 
 	setup_timer(&wl->rx_streaming_timer, wl1271_rx_streaming_timer,
 		    (unsigned long) wl);
@@ -5017,6 +5094,8 @@
 
 	/* Apply default driver configuration. */
 	wl1271_conf_init(wl);
+	wl->bitrate_masks[IEEE80211_BAND_2GHZ] = wl->conf.tx.basic_rate;
+	wl->bitrate_masks[IEEE80211_BAND_5GHZ] = wl->conf.tx.basic_rate_5;
 
 	order = get_order(WL1271_AGGR_BUFFER_SIZE);
 	wl->aggr_buf = (u8 *)__get_free_pages(GFP_KERNEL, order);
diff -rNu a/drivers/net/wireless/wl12xx/modules.order b/drivers/net/wireless/wl12xx/modules.order
--- a/drivers/net/wireless/wl12xx/modules.order	1970-01-01 02:00:00.000000000 +0200
+++ b/drivers/net/wireless/wl12xx/modules.order	2011-12-20 18:29:47.000000000 +0200
@@ -0,0 +1,3 @@
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/drivers/net/wireless/wl12xx/wl12xx.ko
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/drivers/net/wireless/wl12xx/wl12xx_spi.ko
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/drivers/net/wireless/wl12xx/wl12xx_sdio.ko
diff -rNu a/drivers/net/wireless/wl12xx/scan.c b/drivers/net/wireless/wl12xx/scan.c
--- a/drivers/net/wireless/wl12xx/scan.c	2012-03-23 12:18:25.000000000 +0200
+++ b/drivers/net/wireless/wl12xx/scan.c	2011-12-20 18:29:47.000000000 +0200
@@ -28,6 +28,7 @@
 #include "scan.h"
 #include "acx.h"
 #include "ps.h"
+#include "tx.h"
 
 void wl1271_scan_complete_work(struct work_struct *work)
 {
@@ -181,14 +182,7 @@
 		goto out;
 	}
 
-	if ((band == IEEE80211_BAND_2GHZ) &&
-	    !(scan_options & WL1271_SCAN_OPT_PASSIVE) &&
-	    cfg80211_find_vendor_ie(WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P,
-				    wl->scan.req->ie, wl->scan.req->ie_len))
-		cmd->params.tx_rate = cpu_to_le32(CONF_HW_BIT_RATE_6MBPS);
-	else
-		cmd->params.tx_rate = cpu_to_le32(basic_rate);
-
+	cmd->params.tx_rate = cpu_to_le32(basic_rate);
 	cmd->params.n_probe_reqs = wl->conf.scan.num_probe_reqs;
 	cmd->params.tid_trigger = 0;
 	cmd->params.scan_tag = WL1271_SCAN_DEFAULT_TAG;
@@ -239,14 +233,20 @@
 void wl1271_scan_stm(struct wl1271 *wl)
 {
 	int ret = 0;
+	enum ieee80211_band band;
+	u32 rate;
 
 	switch (wl->scan.state) {
 	case WL1271_SCAN_STATE_IDLE:
 		break;
 
 	case WL1271_SCAN_STATE_2GHZ_ACTIVE:
-		ret = wl1271_scan_send(wl, IEEE80211_BAND_2GHZ, false,
-				       wl->conf.tx.basic_rate);
+		band = IEEE80211_BAND_2GHZ;
+		if (wl->scan.req->no_cck)
+			rate = wl1271_tx_min_rate_get(wl, CONF_TX_RATE_MASK_BASIC_P2P);
+		else
+			rate = wl1271_tx_min_rate_get(wl, CONF_TX_RATE_MASK_BASIC);
+		ret = wl1271_scan_send(wl, band, false, rate);
 		if (ret == WL1271_NOTHING_TO_SCAN) {
 			wl->scan.state = WL1271_SCAN_STATE_2GHZ_PASSIVE;
 			wl1271_scan_stm(wl);
@@ -255,8 +255,12 @@
 		break;
 
 	case WL1271_SCAN_STATE_2GHZ_PASSIVE:
-		ret = wl1271_scan_send(wl, IEEE80211_BAND_2GHZ, true,
-				       wl->conf.tx.basic_rate);
+		band = IEEE80211_BAND_2GHZ;
+		if (wl->scan.req->no_cck)
+			rate = wl1271_tx_min_rate_get(wl, CONF_TX_RATE_MASK_BASIC_P2P);
+		else
+			rate = wl1271_tx_min_rate_get(wl, CONF_TX_RATE_MASK_BASIC);
+		ret = wl1271_scan_send(wl, band, true, rate);
 		if (ret == WL1271_NOTHING_TO_SCAN) {
 			if (wl->enable_11a)
 				wl->scan.state = WL1271_SCAN_STATE_5GHZ_ACTIVE;
@@ -268,8 +272,9 @@
 		break;
 
 	case WL1271_SCAN_STATE_5GHZ_ACTIVE:
-		ret = wl1271_scan_send(wl, IEEE80211_BAND_5GHZ, false,
-				       wl->conf.tx.basic_rate_5);
+		band = IEEE80211_BAND_5GHZ;
+		rate = wl1271_tx_min_rate_get(wl, wl->bitrate_masks[band]);
+		ret = wl1271_scan_send(wl, band, false, rate);
 		if (ret == WL1271_NOTHING_TO_SCAN) {
 			wl->scan.state = WL1271_SCAN_STATE_5GHZ_PASSIVE;
 			wl1271_scan_stm(wl);
@@ -278,8 +283,9 @@
 		break;
 
 	case WL1271_SCAN_STATE_5GHZ_PASSIVE:
-		ret = wl1271_scan_send(wl, IEEE80211_BAND_5GHZ, true,
-				       wl->conf.tx.basic_rate_5);
+		band = IEEE80211_BAND_5GHZ;
+		rate = wl1271_tx_min_rate_get(wl, wl->bitrate_masks[band]);
+		ret = wl1271_scan_send(wl, band, true, rate);
 		if (ret == WL1271_NOTHING_TO_SCAN) {
 			wl->scan.state = WL1271_SCAN_STATE_DONE;
 			wl1271_scan_stm(wl);
diff -rNu a/drivers/net/wireless/wl12xx/sdio.c b/drivers/net/wireless/wl12xx/sdio.c
--- a/drivers/net/wireless/wl12xx/sdio.c	2012-03-23 12:18:25.000000000 +0200
+++ b/drivers/net/wireless/wl12xx/sdio.c	2011-12-20 18:29:47.000000000 +0200
@@ -172,7 +172,7 @@
 	/* If enabled, tell runtime PM not to power off the card */
 	if (pm_runtime_enabled(&func->dev)) {
 		ret = pm_runtime_get_sync(&func->dev);
-		if (ret)
+		if (ret < 0)
 			goto out;
 	} else {
 		/* Runtime PM is disabled: power up the card manually */
@@ -253,7 +253,7 @@
 	func->card->quirks |= MMC_QUIRK_LENIENT_FN0;
 
 	/* Use block mode for transferring over one block size of data */
-	func->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
+	//func->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
 
 	wlan_data = wl12xx_get_platform_data();
 	if (IS_ERR(wlan_data)) {
@@ -294,6 +294,8 @@
 	}
 	disable_irq(wl->irq);
 
+	sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
+
 	ret = wl1271_init_ieee80211(wl);
 	if (ret)
 		goto out_irq;
@@ -306,6 +308,7 @@
 
 	/* Tell PM core that we don't need the card to be powered now */
 	pm_runtime_put_noidle(&func->dev);
+	mmc_power_save_host(func->card->host);
 
 	return 0;
 
@@ -321,9 +324,13 @@
 static void __devexit wl1271_remove(struct sdio_func *func)
 {
 	struct wl1271 *wl = sdio_get_drvdata(func);
+	struct mmc_host *host = func->card->host;
 
 	/* Undo decrement done above in wl1271_probe */
 	pm_runtime_get_noresume(&func->dev);
+	mmc_power_restore_host(func->card->host);
+
+	host->pm_flags = host->pm_flags & ~MMC_PM_KEEP_POWER;
 
 	wl1271_unregister_hw(wl);
 	if (wl->irq_wake_enabled) {
@@ -357,6 +364,7 @@
 			goto out;
 		}
 
+		printk("\n\nSetting MMC_PM_KEEP_POWER\n");
 		/* keep power while host suspended */
 		ret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
 		if (ret) {
@@ -376,6 +384,7 @@
 	struct sdio_func *func = dev_to_sdio_func(dev);
 	struct wl1271 *wl = sdio_get_drvdata(func);
 
+	printk("%s\n", __func__);
 	wl1271_debug(DEBUG_MAC80211, "wl1271 resume");
 	if (wl->wow_enabled) {
 		/* claim back host */
diff -rNu a/drivers/net/wireless/wl12xx/tx.c b/drivers/net/wireless/wl12xx/tx.c
--- a/drivers/net/wireless/wl12xx/tx.c	2012-03-23 12:18:25.000000000 +0200
+++ b/drivers/net/wireless/wl12xx/tx.c	2011-12-20 18:29:47.000000000 +0200
@@ -200,9 +200,7 @@
 	u32 len;
 	u32 total_blocks;
 	int id, ret = -EBUSY, ac;
-
-	/* we use 1 spare block */
-	u32 spare_blocks = 1;
+	u32 spare_blocks = wl->tx_spare_blocks;
 
 	if (buf_offset + total_len > WL1271_AGGR_BUFFER_SIZE)
 		return -EAGAIN;
@@ -216,6 +214,10 @@
 	   in the firmware */
 	len = wl12xx_calc_packet_alignment(wl, total_len);
 
+	/* in case of a dummy packet, use default amount of spare mem blocks */
+	if (unlikely(wl12xx_is_dummy_packet(wl, skb)))
+		spare_blocks = TX_HW_BLOCK_SPARE_DEFAULT;
+
 	total_blocks = (len + TX_HW_BLOCK_SIZE - 1) / TX_HW_BLOCK_SIZE +
 		spare_blocks;
 
@@ -525,13 +527,14 @@
 	return total_len;
 }
 
-u32 wl1271_tx_enabled_rates_get(struct wl1271 *wl, u32 rate_set)
+u32 wl1271_tx_enabled_rates_get(struct wl1271 *wl, u32 rate_set,
+				enum ieee80211_band rate_band)
 {
 	struct ieee80211_supported_band *band;
 	u32 enabled_rates = 0;
 	int bit;
 
-	band = wl->hw->wiphy->bands[wl->band];
+	band = wl->hw->wiphy->bands[rate_band];
 	for (bit = 0; bit < band->n_bitrates; bit++) {
 		if (rate_set & 0x1)
 			enabled_rates |= band->bitrates[bit].hw_value;
@@ -1062,20 +1065,10 @@
 	wl1271_warning("Unable to flush all TX buffers, timed out.");
 }
 
-u32 wl1271_tx_min_rate_get(struct wl1271 *wl)
+u32 wl1271_tx_min_rate_get(struct wl1271 *wl, u32 rate_set)
 {
-	int i;
-	u32 rate = 0;
-
-	if (!wl->basic_rate_set) {
-		WARN_ON(1);
-		wl->basic_rate_set = wl->conf.tx.basic_rate;
-	}
-
-	for (i = 0; !rate; i++) {
-		if ((wl->basic_rate_set >> i) & 0x1)
-			rate = 1 << i;
-	}
+	if (WARN_ON(!rate_set))
+		return 0;
 
-	return rate;
+	return BIT(__ffs(rate_set));
 }
diff -rNu a/drivers/net/wireless/wl12xx/tx.h b/drivers/net/wireless/wl12xx/tx.h
--- a/drivers/net/wireless/wl12xx/tx.h	2012-03-23 12:18:25.000000000 +0200
+++ b/drivers/net/wireless/wl12xx/tx.h	2011-12-20 18:29:47.000000000 +0200
@@ -25,6 +25,7 @@
 #ifndef __TX_H__
 #define __TX_H__
 
+#define TX_HW_BLOCK_SPARE_DEFAULT        1
 #define TX_HW_BLOCK_SIZE                 252
 
 #define TX_HW_MGMT_PKT_LIFETIME_TU       2000
@@ -208,8 +209,9 @@
 void wl1271_tx_reset(struct wl1271 *wl, bool reset_tx_queues);
 void wl1271_tx_flush(struct wl1271 *wl);
 u8 wl1271_rate_to_idx(int rate, enum ieee80211_band band);
-u32 wl1271_tx_enabled_rates_get(struct wl1271 *wl, u32 rate_set);
-u32 wl1271_tx_min_rate_get(struct wl1271 *wl);
+u32 wl1271_tx_enabled_rates_get(struct wl1271 *wl, u32 rate_set,
+				enum ieee80211_band rate_band);
+u32 wl1271_tx_min_rate_get(struct wl1271 *wl, u32 rate_set);
 u8 wl1271_tx_get_hlid(struct wl1271 *wl, struct sk_buff *skb);
 void wl1271_tx_reset_link_queues(struct wl1271 *wl, u8 hlid);
 void wl1271_handle_tx_low_watermark(struct wl1271 *wl);
diff -rNu a/drivers/net/wireless/wl12xx/wl12xx.h b/drivers/net/wireless/wl12xx/wl12xx.h
--- a/drivers/net/wireless/wl12xx/wl12xx.h	2012-03-23 12:18:25.000000000 +0200
+++ b/drivers/net/wireless/wl12xx/wl12xx.h	2011-12-20 18:29:47.000000000 +0200
@@ -381,6 +381,7 @@
 	WL1271_FLAG_RX_STREAMING_STARTED,
 	WL1271_FLAG_RECOVERY_IN_PROGRESS,
 	WL1271_FLAG_CS_PROGRESS,
+	WL1271_FLAG_PROBE_RESP_SET,
 };
 
 struct wl1271_link {
@@ -460,6 +461,9 @@
 	u32 tx_allocated_blocks;
 	u32 tx_results_count;
 
+	/* amount of spare TX blocks to use */
+	u32 tx_spare_blocks;
+
 	/* Accounting for allocated / available Tx packets in HW */
 	u32 tx_pkts_freed[NUM_TX_QUEUES];
 	u32 tx_allocated_pkts[NUM_TX_QUEUES];
@@ -557,6 +561,7 @@
 	u32 basic_rate_set;
 	u32 basic_rate;
 	u32 rate_set;
+	u32 bitrate_masks[IEEE80211_NUM_BANDS];
 
 	/* The current band */
 	enum ieee80211_band band;
diff -rNu a/.gitignore b/.gitignore
--- a/.gitignore	2012-03-23 12:18:24.000000000 +0200
+++ b/.gitignore	1970-01-01 02:00:00.000000000 +0200
@@ -1,17 +0,0 @@
-drivers
-include
-net
-compat
-udev
-*~
-git-describe
-compat-release
-master-tag
-Module.symvers
-module.order
-.pc
-code-metrics.txt
-compat_base_tree
-compat_base_tree_version
-compat_version
-
diff -rNu a/include/linux/atomic.h b/include/linux/atomic.h
--- a/include/linux/atomic.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/atomic.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,46 +0,0 @@
-#ifndef _COMPAT_LINUX_ATOMIC_H
-#define _COMPAT_LINUX_ATOMIC_H 1
-
-#include <linux/version.h>
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,36))
-#include_next <linux/atomic.h>
-#else
-
-#include <asm/atomic.h>
-
-/**
- * atomic_inc_not_zero_hint - increment if not null
- * @v: pointer of type atomic_t
- * @hint: probable value of the atomic before the increment
- *
- * This version of atomic_inc_not_zero() gives a hint of probable
- * value of the atomic. This helps processor to not read the memory
- * before doing the atomic read/modify/write cycle, lowering
- * number of bus transactions on some arches.
- *
- * Returns: 0 if increment was not done, 1 otherwise.
- */
-#ifndef atomic_inc_not_zero_hint
-static inline int atomic_inc_not_zero_hint(atomic_t *v, int hint)
-{
-	int val, c = hint;
-
-	/* sanity test, should be removed by compiler if hint is a constant */
-	if (!hint)
-		return atomic_inc_not_zero(v);
-
-	do {
-		val = atomic_cmpxchg(v, c, c + 1);
-		if (val == c)
-			return 1;
-		c = val;
-	} while (c);
-
-	return 0;
-}
-#endif
-
-#endif /* (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,36)) */
-
-#endif	/* _COMPAT_LINUX_ATOMIC_H */
diff -rNu a/include/linux/compat-2.6.20.h b/include/linux/compat-2.6.20.h
--- a/include/linux/compat-2.6.20.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/compat-2.6.20.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,21 +0,0 @@
-#ifndef LINUX_26_20_COMPAT_H
-#define LINUX_26_20_COMPAT_H
-
-#include <linux/version.h>
-
-/* Compat work for 2.6.20 */
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))
-
-#include <linux/workqueue.h>
-
-typedef void (*work_func_t)(struct work_struct *work);
-typedef void (*compat_work_func_t)(void *work);
-static inline void (INIT_WORK)(struct work_struct *work, work_func_t func)
-{
-	INIT_WORK(work, (compat_work_func_t)func, work);
-}
-#undef INIT_WORK
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)) */
-
-#endif /* LINUX_26_20_COMPAT_H */
diff -rNu a/include/linux/compat-2.6.27.h b/include/linux/compat-2.6.27.h
--- a/include/linux/compat-2.6.27.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/compat-2.6.27.h	2011-12-20 18:29:49.000000000 +0200
@@ -250,12 +250,6 @@
 	return ep->speed;
 }
 
-/**
- * lower_32_bits - return bits 0-31 of a number
- * @n: the number we're accessing
- */
-#define lower_32_bits(n) ((u32)(n))
-
 #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)) */
 
 #endif /* LINUX_26_27_COMPAT_H */
diff -rNu a/include/linux/compat-2.6.28.h b/include/linux/compat-2.6.28.h
--- a/include/linux/compat-2.6.28.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/compat-2.6.28.h	2011-12-20 18:29:49.000000000 +0200
@@ -238,10 +238,6 @@
 
 #define alloc_workqueue(name, flags, max_active) __create_workqueue(name, flags, max_active)
 
-#ifndef pr_fmt
-#define pr_fmt(fmt) fmt
-#endif
-
 #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)) */
 
 #endif /* LINUX_26_28_COMPAT_H */
diff -rNu a/include/linux/compat-2.6.31.h b/include/linux/compat-2.6.31.h
--- a/include/linux/compat-2.6.31.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/compat-2.6.31.h	2011-12-20 18:29:49.000000000 +0200
@@ -199,9 +199,6 @@
 #define list_entry_rcu(ptr, type, member) \
 	container_of(rcu_dereference(ptr), type, member)
 
-#define skb_walk_frags(skb, iter)	\
-	for (iter = skb_shinfo(skb)->frag_list; iter; iter = iter->next)
-
 #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)) */
 
 #endif /* LINUX_26_31_COMPAT_H */
diff -rNu a/include/linux/compat-2.6.33.h b/include/linux/compat-2.6.33.h
--- a/include/linux/compat-2.6.33.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/compat-2.6.33.h	2011-12-20 18:29:49.000000000 +0200
@@ -14,6 +14,7 @@
 #endif
 #include <linux/firmware.h>
 
+#if 0
 #define release_firmware compat_release_firmware
 #define request_firmware compat_request_firmware
 #define request_firmware_nowait compat_request_firmware_nowait
@@ -46,6 +47,7 @@
 {
 }
 #endif
+#endif
 
 #define KEY_RFKILL		247	/* Key that controls all radios */
 
@@ -138,12 +140,6 @@
 #endif
 }
 
-#ifdef __GNUC__
-#define __always_unused			__attribute__((unused))
-#else
-#define __always_unused			/* unimplemented */
-#endif
-
 #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)) */
 
 #endif /* LINUX_26_33_COMPAT_H */
diff -rNu a/include/linux/compat-2.6.34.h b/include/linux/compat-2.6.34.h
--- a/include/linux/compat-2.6.34.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/compat-2.6.34.h	2011-12-20 18:29:49.000000000 +0200
@@ -20,11 +20,12 @@
 
 /* netdev_printk helpers, similar to dev_printk */
 
-#ifndef netdev_name
-#define netdev_name(__dev) \
-	((__dev->reg_state != NETREG_REGISTERED) ? \
-		"(unregistered net_device)" : __dev->name)
-#endif
+static inline const char *netdev_name(const struct net_device *dev)
+{
+	if (dev->reg_state != NETREG_REGISTERED)
+		return "(unregistered net_device)";
+	return dev->name;
+}
 
 #define netdev_printk(level, netdev, format, args...)		\
 	dev_printk(level, (netdev)->dev.parent,			\
@@ -243,30 +244,13 @@
 { return 0; }
 
 #define MMC_PM_KEEP_POWER	(1 << 0)	/* preserve card power during suspend */
-#define sdio_set_host_pm_flags(a, b) 0
+//#define sdio_set_host_pm_flags(a, b) 0
 
 #define rcu_dereference_protected(p, c) (p)
 #define rcu_access_pointer(p)   ACCESS_ONCE(p)
 
 #define rcu_dereference_raw(p)	rcu_dereference(p)
 
-#define KEY_WPS_BUTTON		0x211	/* WiFi Protected Setup key */
-
-/*
- * This looks more complex than it should be. But we need to
- * get the type for the ~ right in round_down (it needs to be
- * as wide as the result!), and we want to evaluate the macro
- * arguments just once each.
- */
-#define __round_mask(x, y) ((__typeof__(x))((y)-1))
-#define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1)
-#define round_down(x, y) ((x) & ~__round_mask(x, y))
-
-static inline int rcu_read_lock_held(void)
-{
-	return 1;
-}
-
 #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)) */
 
 #endif /* LINUX_26_34_COMPAT_H */
diff -rNu a/include/linux/compat-2.6.37.h b/include/linux/compat-2.6.37.h
--- a/include/linux/compat-2.6.37.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/compat-2.6.37.h	2011-12-20 18:29:49.000000000 +0200
@@ -124,11 +124,6 @@
 #define RCU_INIT_POINTER(p, v) \
 		p = (typeof(*v) __force __rcu *)(v)
 
-static inline bool skb_has_frag_list(const struct sk_buff *skb)
-{
-	return skb_shinfo(skb)->frag_list != NULL;
-}
-
 #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)) */
 
 #endif /* LINUX_26_37_COMPAT_H */
diff -rNu a/include/linux/compat-2.6.38.h b/include/linux/compat-2.6.38.h
--- a/include/linux/compat-2.6.38.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/compat-2.6.38.h	2011-12-20 18:29:49.000000000 +0200
@@ -46,37 +46,6 @@
 	return skb->csum_start - skb_headroom(skb);
 }
 
-/* from include/linux/printk.h */ 
-#define pr_emerg_once(fmt, ...)					\
-	printk_once(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)
-#define pr_alert_once(fmt, ...)					\
-	printk_once(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)
-#define pr_crit_once(fmt, ...)					\
-	printk_once(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)
-#define pr_err_once(fmt, ...)					\
-	printk_once(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)
-#define pr_warn_once(fmt, ...)					\
-	printk_once(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)
-#define pr_notice_once(fmt, ...)				\
-	printk_once(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)
-#define pr_info_once(fmt, ...)					\
-	printk_once(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)
-#define pr_cont_once(fmt, ...)					\
-	printk_once(KERN_CONT pr_fmt(fmt), ##__VA_ARGS__)
-#if defined(DEBUG)
-#define pr_debug_once(fmt, ...)					\
-	printk_once(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
-#else
-#define pr_debug_once(fmt, ...)					\
-	no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
-#endif
-
-/* include/linux/netdevice.h */
-#define alloc_netdev_mqs(sizeof_priv, name, setup, txqs, rxqs) \
-	alloc_netdev_mq(sizeof_priv, name, setup, max(txqs, rxqs))
-
-#define ETH_P_LINK_CTL	0x886c		/* HPNA, wlan link local tunnel */
-
 #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)) */
 
 #endif /* LINUX_26_38_COMPAT_H */
diff -rNu a/include/linux/compat-2.6.39.h b/include/linux/compat-2.6.39.h
--- a/include/linux/compat-2.6.39.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/compat-2.6.39.h	2011-12-20 18:29:49.000000000 +0200
@@ -64,8 +64,6 @@
 {
 	return get_irq_msi(irq);
 }
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
 static inline void irq_set_noprobe(unsigned int irq)
 {
 	set_irq_noprobe(irq);
@@ -74,7 +72,6 @@
 {
 	set_irq_probe(irq);
 }
-#endif
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
 static inline struct irq_chip *irq_desc_get_chip(struct irq_desc *desc)
diff -rNu a/include/linux/compat-2.6.40.h b/include/linux/compat-2.6.40.h
--- a/include/linux/compat-2.6.40.h	1970-01-01 02:00:00.000000000 +0200
+++ b/include/linux/compat-2.6.40.h	2011-12-20 18:29:49.000000000 +0200
@@ -0,0 +1,29 @@
+#ifndef LINUX_26_40_COMPAT_H
+#define LINUX_26_40_COMPAT_H
+
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,40))
+
+#include <linux/rcupdate.h>
+
+/*
+ * This is not part of The 2.6.37 kernel yet but we
+ * we use it to optimize the backport code we
+ * need to implement. Instead of using ifdefs
+ * to check what version of the check we use
+ * we just replace all checks on current code
+ * with this. I'll submit this upstream too, that
+ * way all we'd have to do is to implement this
+ * for older kernels, then we would not have to
+ * edit the upstrema code for backport efforts.
+ */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
+#define br_port_exists(dev)	(dev->priv_flags & IFF_BRIDGE_PORT)
+#else
+#define br_port_exists(dev)	(dev->br_port)
+#endif
+
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,40)) */
+
+#endif /* LINUX_26_40_COMPAT_H */
diff -rNu a/include/linux/compat-2.6.h b/include/linux/compat-2.6.h
--- a/include/linux/compat-2.6.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/compat-2.6.h	2011-12-20 18:29:49.000000000 +0200
@@ -32,8 +32,6 @@
 #include <linux/compat-2.6.37.h>
 #include <linux/compat-2.6.38.h>
 #include <linux/compat-2.6.39.h>
-#include <linux/compat-3.0.h>
-#include <linux/compat-3.1.h>
-#include <linux/compat-3.2.h>
+#include <linux/compat-2.6.40.h>
 
 #endif /* LINUX_26_COMPAT_H */
diff -rNu a/include/linux/compat-3.0.h b/include/linux/compat-3.0.h
--- a/include/linux/compat-3.0.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/compat-3.0.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,84 +0,0 @@
-#ifndef LINUX_3_0_COMPAT_H
-#define LINUX_3_0_COMPAT_H
-
-#include <linux/version.h>
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
-
-/*
- * since commit 1c5cae815d19ffe02bdfda1260949ef2b1806171
- * "net: call dev_alloc_name from register_netdevice" dev_alloc_name is
- * called automatically. This is not implemented in older kernel
- * versions so it will result in device wrong names.
- */
-static inline int register_netdevice_name(struct net_device *dev)
-{
-	int err;
-
-	if (strchr(dev->name, '%')) {
-		err = dev_alloc_name(dev, dev->name);
-		if (err < 0)
-			return err;
-	}
-
-	return register_netdevice(dev);
-}
-
-#define register_netdevice(dev) register_netdevice_name(dev)
-
-/* BCMA core, see drivers/bcma/ */
-#ifndef BCMA_CORE
-/* Broadcom's specific AMBA core, see drivers/bcma/ */
-struct bcma_device_id {
-	__u16	manuf;
-	__u16	id;
-	__u8	rev;
-	__u8	class;
-};
-#define BCMA_CORE(_manuf, _id, _rev, _class)  \
-	{ .manuf = _manuf, .id = _id, .rev = _rev, .class = _class, }
-#define BCMA_CORETABLE_END  \
-	{ 0, },
-
-#define BCMA_ANY_MANUF		0xFFFF
-#define BCMA_ANY_ID		0xFFFF
-#define BCMA_ANY_REV		0xFF
-#define BCMA_ANY_CLASS		0xFF
-#endif /* BCMA_CORE */
-
-int mac_pton(const char *s, u8 *mac);
-
-int __must_check kstrtoull_from_user(const char __user *s, size_t count, unsigned int base, unsigned long long *res);
-int __must_check kstrtoll_from_user(const char __user *s, size_t count, unsigned int base, long long *res);
-int __must_check kstrtoul_from_user(const char __user *s, size_t count, unsigned int base, unsigned long *res);
-int __must_check kstrtol_from_user(const char __user *s, size_t count, unsigned int base, long *res);
-int __must_check kstrtouint_from_user(const char __user *s, size_t count, unsigned int base, unsigned int *res);
-int __must_check kstrtoint_from_user(const char __user *s, size_t count, unsigned int base, int *res);
-int __must_check kstrtou16_from_user(const char __user *s, size_t count, unsigned int base, u16 *res);
-int __must_check kstrtos16_from_user(const char __user *s, size_t count, unsigned int base, s16 *res);
-int __must_check kstrtou8_from_user(const char __user *s, size_t count, unsigned int base, u8 *res);
-int __must_check kstrtos8_from_user(const char __user *s, size_t count, unsigned int base, s8 *res);
-
-static inline int __must_check kstrtou64_from_user(const char __user *s, size_t count, unsigned int base, u64 *res)
-{
-	return kstrtoull_from_user(s, count, base, res);
-}
-
-static inline int __must_check kstrtos64_from_user(const char __user *s, size_t count, unsigned int base, s64 *res)
-{
-	return kstrtoll_from_user(s, count, base, res);
-}
-
-static inline int __must_check kstrtou32_from_user(const char __user *s, size_t count, unsigned int base, u32 *res)
-{
-	return kstrtouint_from_user(s, count, base, res);
-}
-
-static inline int __must_check kstrtos32_from_user(const char __user *s, size_t count, unsigned int base, s32 *res)
-{
-	return kstrtoint_from_user(s, count, base, res);
-}
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)) */
-
-#endif /* LINUX_3_0_COMPAT_H */
diff -rNu a/include/linux/compat-3.1.h b/include/linux/compat-3.1.h
--- a/include/linux/compat-3.1.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/compat-3.1.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,24 +0,0 @@
-#ifndef LINUX_3_1_COMPAT_H
-#define LINUX_3_1_COMPAT_H
-
-#include <linux/version.h>
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
-
-#define genl_dump_check_consistent(cb, user_hdr, family)
-
-#define IFF_TX_SKB_SHARING	0x10000	/* The interface supports sharing
-					 * skbs on transmit */
-
-#define PCMCIA_DEVICE_MANF_CARD_PROD_ID3(manf, card, v3, vh3) { \
-	.match_flags = PCMCIA_DEV_ID_MATCH_MANF_ID| \
-			PCMCIA_DEV_ID_MATCH_CARD_ID| \
-			PCMCIA_DEV_ID_MATCH_PROD_ID3, \
-	.manf_id = (manf), \
-	.card_id = (card), \
-	.prod_id = { NULL, NULL, (v3), NULL }, \
-	.prod_id_hash = { 0, 0, (vh3), 0 }, }
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0)) */
-
-#endif /* LINUX_3_1_COMPAT_H */
diff -rNu a/include/linux/compat-3.2.h b/include/linux/compat-3.2.h
--- a/include/linux/compat-3.2.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/compat-3.2.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,63 +0,0 @@
-#ifndef LINUX_3_2_COMPAT_H
-#define LINUX_3_2_COMPAT_H
-
-#include <linux/version.h>
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0))
-
-#include <linux/skbuff.h>
-#include <linux/dma-mapping.h>
-
-/*
- * This is not part of The 2.6.37 kernel yet but we
- * we use it to optimize the backport code we
- * need to implement. Instead of using ifdefs
- * to check what version of the check we use
- * we just replace all checks on current code
- * with this. I'll submit this upstream too, that
- * way all we'd have to do is to implement this
- * for older kernels, then we would not have to
- * edit the upstrema code for backport efforts.
- */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
-#define br_port_exists(dev)	(dev->priv_flags & IFF_BRIDGE_PORT)
-#else
-#define br_port_exists(dev)	(dev->br_port)
-#endif
-
-#define PMSG_IS_AUTO(msg)	(((msg).event & PM_EVENT_AUTO) != 0)
-
-/**
- * skb_frag_page - retrieve the page refered to by a paged fragment
- * @frag: the paged fragment
- *
- * Returns the &struct page associated with @frag.
- */
-static inline struct page *skb_frag_page(const skb_frag_t *frag)
-{
-	return frag->page;
-}
-
-/**
- * skb_frag_dma_map - maps a paged fragment via the DMA API
- * @device: the device to map the fragment to
- * @frag: the paged fragment to map
- * @offset: the offset within the fragment (starting at the
- *          fragment's own offset)
- * @size: the number of bytes to map
- * @direction: the direction of the mapping (%PCI_DMA_*)
- *
- * Maps the page associated with @frag to @device.
- */
-static inline dma_addr_t skb_frag_dma_map(struct device *dev,
-					  const skb_frag_t *frag,
-					  size_t offset, size_t size,
-					  enum dma_data_direction dir)
-{
-	return dma_map_page(dev, skb_frag_page(frag),
-			    frag->page_offset + offset, size, dir);
-}
-
-#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0)) */
-
-#endif /* LINUX_3_2_COMPAT_H */
diff -rNu a/include/linux/compat_autoconf.h b/include/linux/compat_autoconf.h
--- a/include/linux/compat_autoconf.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/compat_autoconf.h	2011-12-20 18:29:49.000000000 +0200
@@ -1,37 +1,685 @@
 #ifndef COMPAT_AUTOCONF_INCLUDED
 #define COMPAT_AUTOCONF_INCLUDED
-
 /*
- * This is an example of a compat autconf header file that gets
- * automatically generated by your projet. You will only need this
- * if you are working with a lot of config options.
- *
- * Your project will likely just override this, or leave this as-is.
+ * Automatically generated C config: don't edit
+ * Wed Sep  7 13:41:16 CEST 2011 
+ * compat-wireless-2.6: compat-wireless-2011-05-19-2-gfa00a5a
+ * linux-2.6: v2.6.39-1250-g40f5df0
  */
-
-/*
- * Example automatically generated C config: don't edit
- * Thu Dec 10 10:34:11 PST 2009 
- * compat-wireless-2.6: master-2009-11-19-5-gb4fd4dd
- * linux-2.6: next-20091208
- */
-//#define COMPAT_PROJECT_FOO_RELEASE "master-2009-11-19-5-gb4fd4dd"
-//#define COMPAT_UPSTREAM_FOO_KERNEL_RELEASE "next-20091208"
-
-/* Example kernel version minimum requirement */
-//#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10))
-//#error Compat-wireless requirement: Linux >= 2,6,10
-//#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10) */ 
-
-/* Example hard requirement */
-//#error Compat-wireless requirement: CONFIG_WIRELESS_EXT must be enabled in your kernel
-//#endif /* CONFIG_WIRELESS_EXT */
-
-/*
- * Example of how to match your external modules kconfig options into this.
- * You'll need something to generate this for you.
- */
-//#ifndef CONFIG_FOO_BAR
-//#define CONFIG_FOO_BAR 1
-
+#define COMPAT_RELEASE "compat-wireless-2011-05-19-2-gfa00a5a"
+#define COMPAT_KERNEL_RELEASE "v2.6.39-1250-g40f5df0"
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+#error Compat-wireless requirement: Linux >= 2,6,24
+#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24) */ 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+#endif /* CONFIG_COMPAT_KERNEL_24 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+#endif /* CONFIG_COMPAT_KERNEL_27 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33))
+#if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)
+#endif /* CONFIG_FW_LOADER */
+#endif /* CONFIG_COMPAT_KERNEL_33 */
+#ifndef CONFIG_MAC80211
+#define CONFIG_MAC80211 1
+#endif /* CONFIG_MAC80211 */ 
+#ifndef CONFIG_MAC80211_RC_DEFAULT
+#define CONFIG_MAC80211_RC_DEFAULT "minstrel_ht"
+#endif /* CONFIG_MAC80211_RC_DEFAULT */ 
+#ifndef CONFIG_MAC80211_RC_DEFAULT_MINSTREL
+#define CONFIG_MAC80211_RC_DEFAULT_MINSTREL 1
+#endif /* CONFIG_MAC80211_RC_DEFAULT_MINSTREL */ 
+#ifndef CONFIG_COMPAT_MAC80211_RC_DEFAULT
+#define CONFIG_COMPAT_MAC80211_RC_DEFAULT "minstrel_ht"
+#endif /* CONFIG_COMPAT_MAC80211_RC_DEFAULT */ 
+#ifndef CONFIG_MAC80211_RC_PID
+#define CONFIG_MAC80211_RC_PID 1
+#endif /* CONFIG_MAC80211_RC_PID */ 
+#ifndef CONFIG_MAC80211_RC_MINSTREL
+#define CONFIG_MAC80211_RC_MINSTREL 1
+#endif /* CONFIG_MAC80211_RC_MINSTREL */ 
+#ifndef CONFIG_MAC80211_RC_MINSTREL_HT
+#define CONFIG_MAC80211_RC_MINSTREL_HT 1
+#endif /* CONFIG_MAC80211_RC_MINSTREL_HT */ 
+#if defined(CONFIG_LEDS_TRIGGERS) || defined(CONFIG_LEDS_TRIGGERS_MODULE)
+#ifndef CONFIG_MAC80211_LEDS
+#define CONFIG_MAC80211_LEDS 1
+#endif /* CONFIG_MAC80211_LEDS */ 
+#endif /* CONFIG_LEDS_TRIGGERS */
+#ifndef CONFIG_MAC80211_MESH
+#define CONFIG_MAC80211_MESH 1
+#endif /* CONFIG_MAC80211_MESH */ 
+#ifndef CONFIG_CFG80211
+#define CONFIG_CFG80211 1
+#endif /* CONFIG_CFG80211 */ 
+#ifndef CONFIG_CFG80211_DEFAULT_PS
+#define CONFIG_CFG80211_DEFAULT_PS 1
+#endif /* CONFIG_CFG80211_DEFAULT_PS */ 
+#ifndef CONFIG_LIB80211
+#define CONFIG_LIB80211 1
+#endif /* CONFIG_LIB80211 */ 
+#ifndef CONFIG_LIB80211_CRYPT_WEP
+#define CONFIG_LIB80211_CRYPT_WEP 1
+#endif /* CONFIG_LIB80211_CRYPT_WEP */ 
+#ifndef CONFIG_LIB80211_CRYPT_CCMP
+#define CONFIG_LIB80211_CRYPT_CCMP 1
+#endif /* CONFIG_LIB80211_CRYPT_CCMP */ 
+#ifndef CONFIG_LIB80211_CRYPT_TKIP
+#define CONFIG_LIB80211_CRYPT_TKIP 1
+#endif /* CONFIG_LIB80211_CRYPT_TKIP */ 
+#ifndef CONFIG_BT
+#define CONFIG_BT 1
+#endif /* CONFIG_BT */ 
+#ifndef CONFIG_COMPAT_BT_L2CAP
+#define CONFIG_COMPAT_BT_L2CAP 1
+#endif /* CONFIG_COMPAT_BT_L2CAP */ 
+#ifndef CONFIG_COMPAT_BT_SCO
+#define CONFIG_COMPAT_BT_SCO 1
+#endif /* CONFIG_COMPAT_BT_SCO */ 
+#ifndef CONFIG_BT_RFCOMM
+#define CONFIG_BT_RFCOMM 1
+#endif /* CONFIG_BT_RFCOMM */ 
+#ifndef CONFIG_BT_RFCOMM_TTY
+#define CONFIG_BT_RFCOMM_TTY 1
+#endif /* CONFIG_BT_RFCOMM_TTY */ 
+#ifndef CONFIG_BT_BNEP
+#define CONFIG_BT_BNEP 1
+#endif /* CONFIG_BT_BNEP */ 
+#ifndef CONFIG_BT_BNEP_MC_FILTER
+#define CONFIG_BT_BNEP_MC_FILTER 1
+#endif /* CONFIG_BT_BNEP_MC_FILTER */ 
+#ifndef CONFIG_BT_BNEP_PROTO_FILTER
+#define CONFIG_BT_BNEP_PROTO_FILTER 1
+#endif /* CONFIG_BT_BNEP_PROTO_FILTER */ 
+#if defined(CONFIG_ISDN_CAPI) || defined(CONFIG_ISDN_CAPI_MODULE)
+#ifndef CONFIG_BT_CMTP
+#define CONFIG_BT_CMTP 1
+#endif /* CONFIG_BT_CMTP */ 
+#endif /* CONFIG_ISDN_CAPI */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28))
+#ifndef CONFIG_COMPAT_BT_HIDP
+#define CONFIG_COMPAT_BT_HIDP 1
+#endif /* CONFIG_COMPAT_BT_HIDP */ 
+#endif /* CONFIG_COMPAT_KERNEL_28 */
+#ifndef CONFIG_BT_HCIUART
+#define CONFIG_BT_HCIUART "M"
+#endif /* CONFIG_BT_HCIUART */ 
+#ifndef CONFIG_BT_HCIUART_H4
+#define CONFIG_BT_HCIUART_H4 1
+#endif /* CONFIG_BT_HCIUART_H4 */ 
+#ifndef CONFIG_BT_HCIUART_BCSP
+#define CONFIG_BT_HCIUART_BCSP 1
+#endif /* CONFIG_BT_HCIUART_BCSP */ 
+#ifndef CONFIG_BT_HCIUART_ATH3K
+#define CONFIG_BT_HCIUART_ATH3K 1
+#endif /* CONFIG_BT_HCIUART_ATH3K */ 
+#ifndef CONFIG_BT_HCIUART_LL
+#define CONFIG_BT_HCIUART_LL 1
+#endif /* CONFIG_BT_HCIUART_LL */ 
+#ifndef CONFIG_BT_HCIVHCI
+#define CONFIG_BT_HCIVHCI 1
+#endif /* CONFIG_BT_HCIVHCI */ 
+#ifndef CONFIG_BT_MRVL
+#define CONFIG_BT_MRVL 1
+#endif /* CONFIG_BT_MRVL */ 
+#if defined(CONFIG_PCMCIA) || defined(CONFIG_PCMCIA_MODULE)
+#ifndef CONFIG_BT_HCIDTL1
+#define CONFIG_BT_HCIDTL1 1
+#endif /* CONFIG_BT_HCIDTL1 */ 
+#ifndef CONFIG_BT_HCIBT3C
+#define CONFIG_BT_HCIBT3C 1
+#endif /* CONFIG_BT_HCIBT3C */ 
+#ifndef CONFIG_BT_HCIBLUECARD
+#define CONFIG_BT_HCIBLUECARD 1
+#endif /* CONFIG_BT_HCIBLUECARD */ 
+#ifndef CONFIG_BT_HCIBTUART
+#define CONFIG_BT_HCIBTUART 1
+#endif /* CONFIG_BT_HCIBTUART */ 
+#endif /* CONFIG_PCMCIA */
+#if defined(CONFIG_WIRELESS_EXT) || defined(CONFIG_WIRELESS_EXT_MODULE)
+#ifndef CONFIG_CFG80211_WEXT
+#define CONFIG_CFG80211_WEXT 1
+#endif /* CONFIG_CFG80211_WEXT */ 
+#else /* CONFIG_CFG80211_WEXT */
+#endif /* CONFIG_WIRELESS_EXT */
+#if defined(CONFIG_STAGING) || defined(CONFIG_STAGING_MODULE)
+#ifndef CONFIG_COMPAT_STAGING
+#define CONFIG_COMPAT_STAGING 1
+#endif /* CONFIG_COMPAT_STAGING */ 
+#endif /* CONFIG_STAGING */
+#ifndef CONFIG_MAC80211_HWSIM
+#define CONFIG_MAC80211_HWSIM 1
+#endif /* CONFIG_MAC80211_HWSIM */ 
+#ifndef CONFIG_ATH5K
+#define CONFIG_ATH5K 1
+#endif /* CONFIG_ATH5K */ 
+#ifndef CONFIG_ATH9K
+#define CONFIG_ATH9K 1
+#endif /* CONFIG_ATH9K */ 
+#ifndef CONFIG_ATH9K_HW
+#define CONFIG_ATH9K_HW 1
+#endif /* CONFIG_ATH9K_HW */ 
+#ifndef CONFIG_ATH9K_COMMON
+#define CONFIG_ATH9K_COMMON 1
+#endif /* CONFIG_ATH9K_COMMON */ 
+#ifndef CONFIG_ATH9K_RATE_CONTROL
+#define CONFIG_ATH9K_RATE_CONTROL 1
+#endif /* CONFIG_ATH9K_RATE_CONTROL */ 
+#if defined(CONFIG_PCI) || defined(CONFIG_PCI_MODULE)
+#ifndef CONFIG_ATH5K_PCI
+#define CONFIG_ATH5K_PCI 1
+#endif /* CONFIG_ATH5K_PCI */ 
+#ifndef CONFIG_ATH9K_PCI
+#define CONFIG_ATH9K_PCI 1
+#endif /* CONFIG_ATH9K_PCI */ 
+#ifndef CONFIG_IWLAGN
+#define CONFIG_IWLAGN 1
+#endif /* CONFIG_IWLAGN */ 
+#ifndef CONFIG_IWL_P2P
+#define CONFIG_IWL_P2P 1
+#endif /* CONFIG_IWL_P2P */ 
+#ifndef CONFIG_IWLWIFI_LEGACY
+#define CONFIG_IWLWIFI_LEGACY 1
+#endif /* CONFIG_IWLWIFI_LEGACY */ 
+#ifndef CONFIG_COMPAT_IWL4965
+#define CONFIG_COMPAT_IWL4965 1
+#endif /* CONFIG_COMPAT_IWL4965 */ 
+#ifndef CONFIG_IWL3945
+#define CONFIG_IWL3945 1
+#endif /* CONFIG_IWL3945 */ 
+#ifndef CONFIG_B43
+#define CONFIG_B43 1
+#endif /* CONFIG_B43 */ 
+#ifndef CONFIG_B43_HWRNG
+#define CONFIG_B43_HWRNG 1
+#endif /* CONFIG_B43_HWRNG */ 
+#ifndef CONFIG_B43_PCI_AUTOSELECT
+#define CONFIG_B43_PCI_AUTOSELECT 1
+#endif /* CONFIG_B43_PCI_AUTOSELECT */ 
+#if defined(CONFIG_PCMCIA) || defined(CONFIG_PCMCIA_MODULE)
+#ifndef CONFIG_B43_PCMCIA
+#define CONFIG_B43_PCMCIA 1
+#endif /* CONFIG_B43_PCMCIA */ 
+#endif /* CONFIG_PCMCIA */
+#if defined(CONFIG_MAC80211_LEDS) || defined(CONFIG_MAC80211_LEDS_MODULE)
+#ifndef CONFIG_B43_LEDS
+#define CONFIG_B43_LEDS 1
+#endif /* CONFIG_B43_LEDS */ 
+#endif /* CONFIG_MAC80211_LEDS */
+#ifndef CONFIG_B43_PHY_LP
+#define CONFIG_B43_PHY_LP 1
+#endif /* CONFIG_B43_PHY_LP */ 
+#ifndef CONFIG_B43_PHY_N
+#define CONFIG_B43_PHY_N 1
+#endif /* CONFIG_B43_PHY_N */ 
+#ifndef CONFIG_B43LEGACY
+#define CONFIG_B43LEGACY 1
+#endif /* CONFIG_B43LEGACY */ 
+#ifndef CONFIG_B43LEGACY_HWRNG
+#define CONFIG_B43LEGACY_HWRNG 1
+#endif /* CONFIG_B43LEGACY_HWRNG */ 
+#ifndef CONFIG_B43LEGACY_PCI_AUTOSELECT
+#define CONFIG_B43LEGACY_PCI_AUTOSELECT 1
+#endif /* CONFIG_B43LEGACY_PCI_AUTOSELECT */ 
+#if defined(CONFIG_MAC80211_LEDS) || defined(CONFIG_MAC80211_LEDS_MODULE)
+#ifndef CONFIG_B43LEGACY_LEDS
+#define CONFIG_B43LEGACY_LEDS 1
+#endif /* CONFIG_B43LEGACY_LEDS */ 
+#endif /* CONFIG_MAC80211_LEDS */
+#ifndef CONFIG_B43LEGACY_DMA
+#define CONFIG_B43LEGACY_DMA 1
+#endif /* CONFIG_B43LEGACY_DMA */ 
+#ifndef CONFIG_B43LEGACY_PIO
+#define CONFIG_B43LEGACY_PIO 1
+#endif /* CONFIG_B43LEGACY_PIO */ 
+#if defined(CONFIG_WIRELESS_EXT) || defined(CONFIG_WIRELESS_EXT_MODULE)
+#ifndef CONFIG_LIBIPW
+#define CONFIG_LIBIPW 1
+#endif /* CONFIG_LIBIPW */ 
+#ifndef CONFIG_IPW2100
+#define CONFIG_IPW2100 1
+#endif /* CONFIG_IPW2100 */ 
+#ifndef CONFIG_IPW2100_MONITOR
+#define CONFIG_IPW2100_MONITOR 1
+#endif /* CONFIG_IPW2100_MONITOR */ 
+#ifndef CONFIG_IPW2200
+#define CONFIG_IPW2200 1
+#endif /* CONFIG_IPW2200 */ 
+#ifndef CONFIG_IPW2200_MONITOR
+#define CONFIG_IPW2200_MONITOR 1
+#endif /* CONFIG_IPW2200_MONITOR */ 
+#ifndef CONFIG_IPW2200_RADIOTAP
+#define CONFIG_IPW2200_RADIOTAP 1
+#endif /* CONFIG_IPW2200_RADIOTAP */ 
+#ifndef CONFIG_IPW2200_PROMISCUOUS
+#define CONFIG_IPW2200_PROMISCUOUS 1
+#endif /* CONFIG_IPW2200_PROMISCUOUS */ 
+#ifndef CONFIG_IPW2200_QOS
+#define CONFIG_IPW2200_QOS 1
+#endif /* CONFIG_IPW2200_QOS */ 
+#endif /* CONFIG_WIRELESS_EXT */
+#if defined(CONFIG_SSB) || defined(CONFIG_SSB_MODULE)
+#ifndef CONFIG_SSB_SPROM
+#define CONFIG_SSB_SPROM 1
+#endif /* CONFIG_SSB_SPROM */ 
+#ifndef CONFIG_SSB_BLOCKIO
+#define CONFIG_SSB_BLOCKIO 1
+#endif /* CONFIG_SSB_BLOCKIO */ 
+#ifndef CONFIG_SSB_PCIHOST
+#define CONFIG_SSB_PCIHOST 1
+#endif /* CONFIG_SSB_PCIHOST */ 
+#ifndef CONFIG_SSB_B43_PCI_BRIDGE
+#define CONFIG_SSB_B43_PCI_BRIDGE 1
+#endif /* CONFIG_SSB_B43_PCI_BRIDGE */ 
+#if defined(CONFIG_PCMCIA) || defined(CONFIG_PCMCIA_MODULE)
+#ifndef CONFIG_SSB_PCMCIAHOST
+#define CONFIG_SSB_PCMCIAHOST 1
+#endif /* CONFIG_SSB_PCMCIAHOST */ 
+#endif /* CONFIG_PCMCIA */
+#ifndef CONFIG_SSB_DRIVER_PCICORE
+#define CONFIG_SSB_DRIVER_PCICORE 1
+#endif /* CONFIG_SSB_DRIVER_PCICORE */ 
+#endif /* CONFIG_SSB */
+#ifndef CONFIG_P54_PCI
+#define CONFIG_P54_PCI 1
+#endif /* CONFIG_P54_PCI */ 
+#ifndef CONFIG_B44
+#define CONFIG_B44 1
+#endif /* CONFIG_B44 */ 
+#ifndef CONFIG_B44_PCI
+#define CONFIG_B44_PCI 1
+#endif /* CONFIG_B44_PCI */ 
+#ifndef CONFIG_RTL8180
+#define CONFIG_RTL8180 1
+#endif /* CONFIG_RTL8180 */ 
+#ifndef CONFIG_ADM8211
+#define CONFIG_ADM8211 1
+#endif /* CONFIG_ADM8211 */ 
+#ifndef CONFIG_RT2X00_LIB_PCI
+#define CONFIG_RT2X00_LIB_PCI 1
+#endif /* CONFIG_RT2X00_LIB_PCI */ 
+#ifndef CONFIG_RT2400PCI
+#define CONFIG_RT2400PCI 1
+#endif /* CONFIG_RT2400PCI */ 
+#ifndef CONFIG_RT2500PCI
+#define CONFIG_RT2500PCI 1
+#endif /* CONFIG_RT2500PCI */ 
+#if defined(CONFIG_CRC_CCITT) || defined(CONFIG_CRC_CCITT_MODULE)
+#ifndef CONFIG_RT2800PCI
+#define CONFIG_RT2800PCI 1
+#endif /* CONFIG_RT2800PCI */ 
+#ifndef CONFIG_RT2800PCI_RT33XX
+#define CONFIG_RT2800PCI_RT33XX 1
+#endif /* CONFIG_RT2800PCI_RT33XX */ 
+#endif /* CONFIG_CRC_CCITT */
+#if defined(CONFIG_CRC_ITU_T) || defined(CONFIG_CRC_ITU_T_MODULE)
+#ifndef CONFIG_RT61PCI
+#define CONFIG_RT61PCI 1
+#endif /* CONFIG_RT61PCI */ 
+#endif /* CONFIG_CRC_ITU_T */
+#ifndef CONFIG_MWL8K
+#define CONFIG_MWL8K 1
+#endif /* CONFIG_MWL8K */ 
+#ifndef CONFIG_ATL1
+#define CONFIG_ATL1 1
+#endif /* CONFIG_ATL1 */ 
+#ifndef CONFIG_ATL2
+#define CONFIG_ATL2 1
+#endif /* CONFIG_ATL2 */ 
+#ifndef CONFIG_ATL1E
+#define CONFIG_ATL1E 1
+#endif /* CONFIG_ATL1E */ 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+#undef CONFIG_ATL1C
+#else /* CONFIG_COMPAT_KERNEL_27 */
+#ifndef CONFIG_ATL1C
+#define CONFIG_ATL1C 1
+#endif /* CONFIG_ATL1C */ 
+#endif /* CONFIG_COMPAT_KERNEL_27 */
+#if defined(CONFIG_WIRELESS_EXT) || defined(CONFIG_WIRELESS_EXT_MODULE)
+#ifndef CONFIG_HERMES
+#define CONFIG_HERMES 1
+#endif /* CONFIG_HERMES */ 
+#ifndef CONFIG_HERMES_CACHE_FW_ON_INIT
+#define CONFIG_HERMES_CACHE_FW_ON_INIT 1
+#endif /* CONFIG_HERMES_CACHE_FW_ON_INIT */ 
+#if defined(CONFIG_PPC_PMAC) || defined(CONFIG_PPC_PMAC_MODULE)
+#ifndef CONFIG_APPLE_AIRPORT
+#define CONFIG_APPLE_AIRPORT 1
+#endif /* CONFIG_APPLE_AIRPORT */ 
+#endif /* CONFIG_PPC_PMAC */
+#ifndef CONFIG_PLX_HERMES
+#define CONFIG_PLX_HERMES 1
+#endif /* CONFIG_PLX_HERMES */ 
+#ifndef CONFIG_TMD_HERMES
+#define CONFIG_TMD_HERMES 1
+#endif /* CONFIG_TMD_HERMES */ 
+#ifndef CONFIG_NORTEL_HERMES
+#define CONFIG_NORTEL_HERMES 1
+#endif /* CONFIG_NORTEL_HERMES */ 
+#ifndef CONFIG_PCI_HERMES
+#define CONFIG_PCI_HERMES 1
+#endif /* CONFIG_PCI_HERMES */ 
+#if defined(CONFIG_PCMCIA) || defined(CONFIG_PCMCIA_MODULE)
+#ifndef CONFIG_PCMCIA_HERMES
+#define CONFIG_PCMCIA_HERMES 1
+#endif /* CONFIG_PCMCIA_HERMES */ 
+#ifndef CONFIG_PCMCIA_SPECTRUM
+#define CONFIG_PCMCIA_SPECTRUM 1
+#endif /* CONFIG_PCMCIA_SPECTRUM */ 
+#endif /* CONFIG_PCMCIA */
+#endif /* CONFIG_WIRELESS_EXT */
+#ifndef CONFIG_RTL8192CE
+#define CONFIG_RTL8192CE 1
+#endif /* CONFIG_RTL8192CE */ 
+#ifndef CONFIG_RTL8192SE
+#define CONFIG_RTL8192SE 1
+#endif /* CONFIG_RTL8192SE */ 
+#if defined(CONFIG_COMPAT_STAGING) || defined(CONFIG_COMPAT_STAGING_MODULE)
+#ifndef CONFIG_BRCMSMAC
+#define CONFIG_BRCMSMAC 1
+#endif /* CONFIG_BRCMSMAC */ 
+#endif /* CONFIG_COMPAT_STAGING */
+#endif /* CONFIG_PCI */
+#if defined(CONFIG_PCMCIA) || defined(CONFIG_PCMCIA_MODULE)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+#undef CONFIG_LIBERTAS
+#undef CONFIG_LIBERTAS_CS
+#else /* CONFIG_COMPAT_KERNEL_27 */
+#ifndef CONFIG_LIBERTAS_CS
+#define CONFIG_LIBERTAS_CS 1
+#endif /* CONFIG_LIBERTAS_CS */ 
+#endif /* CONFIG_COMPAT_KERNEL_27 */
+#endif /* CONFIG_PCMCIA */
+#ifndef CONFIG_EEPROM_93CX6
+#define CONFIG_EEPROM_93CX6 1
+#endif /* CONFIG_EEPROM_93CX6 */ 
+#if defined(CONFIG_USB) || defined(CONFIG_USB_MODULE)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
+#ifndef CONFIG_COMPAT_ZD1211RW
+#define CONFIG_COMPAT_ZD1211RW 1
+#endif /* CONFIG_COMPAT_ZD1211RW */ 
+#endif /* CONFIG_COMPAT_KERNEL_29 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
+#undef CONFIG_USB_COMPAT_USBNET
+#undef CONFIG_USB_NET_COMPAT_RNDIS_HOST
+#undef CONFIG_USB_NET_COMPAT_RNDIS_WLAN
+#undef CONFIG_USB_NET_COMPAT_CDCETHER
+#else /* CONFIG_COMPAT_KERNEL_29 */
+#ifndef CONFIG_USB_COMPAT_USBNET
+#define CONFIG_USB_COMPAT_USBNET 1
+#endif /* CONFIG_USB_COMPAT_USBNET */ 
+#if defined(CONFIG_USB_NET_CDCETHER) || defined(CONFIG_USB_NET_CDCETHER_MODULE)
+#ifndef CONFIG_USB_NET_COMPAT_RNDIS_HOST
+#define CONFIG_USB_NET_COMPAT_RNDIS_HOST 1
+#endif /* CONFIG_USB_NET_COMPAT_RNDIS_HOST */ 
+#ifndef CONFIG_USB_NET_COMPAT_RNDIS_WLAN
+#define CONFIG_USB_NET_COMPAT_RNDIS_WLAN 1
+#endif /* CONFIG_USB_NET_COMPAT_RNDIS_WLAN */ 
+#endif /* CONFIG_USB_NET_CDCETHER */
+#if defined(CONFIG_USB_NET_CDCETHER_MODULE) || defined(CONFIG_USB_NET_CDCETHER_MODULE_MODULE)
+#ifndef CONFIG_USB_NET_COMPAT_RNDIS_HOST
+#define CONFIG_USB_NET_COMPAT_RNDIS_HOST 1
+#endif /* CONFIG_USB_NET_COMPAT_RNDIS_HOST */ 
+#ifndef CONFIG_USB_NET_COMPAT_RNDIS_WLAN
+#define CONFIG_USB_NET_COMPAT_RNDIS_WLAN 1
+#endif /* CONFIG_USB_NET_COMPAT_RNDIS_WLAN */ 
+#endif /* CONFIG_USB_NET_CDCETHER */
+#ifndef CONFIG_USB_NET_COMPAT_CDCETHER
+#define CONFIG_USB_NET_COMPAT_CDCETHER 1
+#endif /* CONFIG_USB_NET_COMPAT_CDCETHER */ 
+#endif /* CONFIG_COMPAT_KERNEL_29 */
+#ifndef CONFIG_P54_USB
+#define CONFIG_P54_USB 1
+#endif /* CONFIG_P54_USB */ 
+#ifndef CONFIG_RTL8187
+#define CONFIG_RTL8187 1
+#endif /* CONFIG_RTL8187 */ 
+#if defined(CONFIG_MAC80211_LEDS) || defined(CONFIG_MAC80211_LEDS_MODULE)
+#ifndef CONFIG_RTL8187_LEDS
+#define CONFIG_RTL8187_LEDS 1
+#endif /* CONFIG_RTL8187_LEDS */ 
+#endif /* CONFIG_MAC80211_LEDS */
+#ifndef CONFIG_AT76C50X_USB
+#define CONFIG_AT76C50X_USB 1
+#endif /* CONFIG_AT76C50X_USB */ 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29))
+#ifndef CONFIG_CARL9170
+#define CONFIG_CARL9170 1
+#endif /* CONFIG_CARL9170 */ 
+#if defined(CONFIG_MAC80211_LEDS) || defined(CONFIG_MAC80211_LEDS_MODULE)
+#ifndef CONFIG_CARL9170_LEDS
+#define CONFIG_CARL9170_LEDS 1
+#endif /* CONFIG_CARL9170_LEDS */ 
+#endif /* CONFIG_MAC80211_LEDS */
+#endif /* CONFIG_COMPAT_KERNEL_29 */
+#ifndef CONFIG_COMPAT_USB_URB_THREAD_FIX
+#define CONFIG_COMPAT_USB_URB_THREAD_FIX 1
+#endif /* CONFIG_COMPAT_USB_URB_THREAD_FIX */ 
+#ifndef CONFIG_ATH9K_HTC
+#define CONFIG_ATH9K_HTC 1
+#endif /* CONFIG_ATH9K_HTC */ 
+#ifndef CONFIG_RT2500USB
+#define CONFIG_RT2500USB 1
+#endif /* CONFIG_RT2500USB */ 
+#if defined(CONFIG_CRC_CCITT) || defined(CONFIG_CRC_CCITT_MODULE)
+#ifndef CONFIG_RT2800USB
+#define CONFIG_RT2800USB 1
+#endif /* CONFIG_RT2800USB */ 
+#ifndef CONFIG_RT2800USB_RT33XX
+#define CONFIG_RT2800USB_RT33XX 1
+#endif /* CONFIG_RT2800USB_RT33XX */ 
+#ifndef CONFIG_RT2800USB_UNKNOWN
+#define CONFIG_RT2800USB_UNKNOWN 1
+#endif /* CONFIG_RT2800USB_UNKNOWN */ 
+#endif /* CONFIG_CRC_CCITT */
+#ifndef CONFIG_RT2X00_LIB_USB
+#define CONFIG_RT2X00_LIB_USB 1
+#endif /* CONFIG_RT2X00_LIB_USB */ 
+#if defined(CONFIG_CRC_ITU_T) || defined(CONFIG_CRC_ITU_T_MODULE)
+#ifndef CONFIG_RT73USB
+#define CONFIG_RT73USB 1
+#endif /* CONFIG_RT73USB */ 
+#endif /* CONFIG_CRC_ITU_T */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+#undef CONFIG_LIBERTAS_THINFIRM_USB
+#undef CONFIG_LIBERTAS_USB
+#else /* CONFIG_COMPAT_KERNEL_27 */
+#ifndef CONFIG_LIBERTAS_THINFIRM_USB
+#define CONFIG_LIBERTAS_THINFIRM_USB 1
+#endif /* CONFIG_LIBERTAS_THINFIRM_USB */ 
+#ifndef CONFIG_LIBERTAS_USB
+#define CONFIG_LIBERTAS_USB 1
+#endif /* CONFIG_LIBERTAS_USB */ 
+#endif /* CONFIG_COMPAT_KERNEL_27 */
+#ifndef CONFIG_ORINOCO_USB
+#define CONFIG_ORINOCO_USB 1
+#endif /* CONFIG_ORINOCO_USB */ 
+#ifndef CONFIG_BT_HCIBTUSB
+#define CONFIG_BT_HCIBTUSB 1
+#endif /* CONFIG_BT_HCIBTUSB */ 
+#ifndef CONFIG_BT_HCIBCM203X
+#define CONFIG_BT_HCIBCM203X 1
+#endif /* CONFIG_BT_HCIBCM203X */ 
+#ifndef CONFIG_BT_HCIBPA10X
+#define CONFIG_BT_HCIBPA10X 1
+#endif /* CONFIG_BT_HCIBPA10X */ 
+#ifndef CONFIG_BT_HCIBFUSB
+#define CONFIG_BT_HCIBFUSB 1
+#endif /* CONFIG_BT_HCIBFUSB */ 
+#ifndef CONFIG_BT_ATH3K
+#define CONFIG_BT_ATH3K 1
+#endif /* CONFIG_BT_ATH3K */ 
+#ifndef CONFIG_RTL8192CU
+#define CONFIG_RTL8192CU 1
+#endif /* CONFIG_RTL8192CU */ 
+#endif /* CONFIG_USB */
+#if defined(CONFIG_SPI_MASTER) || defined(CONFIG_SPI_MASTER_MODULE)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+#if defined(CONFIG_CRC7) || defined(CONFIG_CRC7_MODULE)
+#ifndef CONFIG_WL1251_SPI
+#define CONFIG_WL1251_SPI 1
+#endif /* CONFIG_WL1251_SPI */ 
+#ifndef CONFIG_WL12XX_SPI
+#define CONFIG_WL12XX_SPI 1
+#endif /* CONFIG_WL12XX_SPI */ 
+#endif /* CONFIG_CRC7 */
+#ifndef CONFIG_P54_SPI
+#define CONFIG_P54_SPI 1
+#endif /* CONFIG_P54_SPI */ 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+#undef CONFIG_LIBERTAS_SPI
+#else /* CONFIG_COMPAT_KERNEL_27 */
+#ifndef CONFIG_LIBERTAS_SPI
+#define CONFIG_LIBERTAS_SPI 1
+#endif /* CONFIG_LIBERTAS_SPI */ 
+#endif /* CONFIG_COMPAT_KERNEL_27 */
+#endif /* CONFIG_COMPAT_KERNEL_25 */
+#endif /* CONFIG_SPI_MASTER */
+#if defined(CONFIG_MMC) || defined(CONFIG_MMC_MODULE)
+#ifndef CONFIG_SSB_SDIOHOST
+#define CONFIG_SSB_SDIOHOST 1
+#endif /* CONFIG_SSB_SDIOHOST */ 
+#ifndef CONFIG_B43_SDIO
+#define CONFIG_B43_SDIO 1
+#endif /* CONFIG_B43_SDIO */ 
+#if defined(CONFIG_CRC7) || defined(CONFIG_CRC7_MODULE)
+#if defined(CONFIG_WL12XX_PLATFORM_DATA) || defined(CONFIG_WL12XX_PLATFORM_DATA_MODULE)
+#ifndef CONFIG_COMPAT_WL1251_SDIO
+#define CONFIG_COMPAT_WL1251_SDIO 1
+#endif /* CONFIG_COMPAT_WL1251_SDIO */ 
+#endif /* CONFIG_WL12XX_PLATFORM_DATA */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
+#if defined(CONFIG_WL12XX_PLATFORM_DATA) || defined(CONFIG_WL12XX_PLATFORM_DATA_MODULE)
+#ifndef CONFIG_COMPAT_WL12XX_SDIO
+#define CONFIG_COMPAT_WL12XX_SDIO 1
+#endif /* CONFIG_COMPAT_WL12XX_SDIO */ 
+#endif /* CONFIG_WL12XX_PLATFORM_DATA */
+#endif /* CONFIG_COMPAT_KERNEL_32 */
+#endif /* CONFIG_CRC7 */
+#ifndef CONFIG_MWIFIEX_SDIO
+#define CONFIG_MWIFIEX_SDIO 1
+#endif /* CONFIG_MWIFIEX_SDIO */ 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+#undef CONFIG_LIBERTAS_SDIO
+#else /* CONFIG_COMPAT_KERNEL_27 */
+#ifndef CONFIG_LIBERTAS_SDIO
+#define CONFIG_LIBERTAS_SDIO 1
+#endif /* CONFIG_LIBERTAS_SDIO */ 
+#endif /* CONFIG_COMPAT_KERNEL_27 */
+#ifndef CONFIG_IWM
+#define CONFIG_IWM 1
+#endif /* CONFIG_IWM */ 
+#ifndef CONFIG_BT_HCIBTSDIO
+#define CONFIG_BT_HCIBTSDIO 1
+#endif /* CONFIG_BT_HCIBTSDIO */ 
+#ifndef CONFIG_BT_MRVL_SDIO
+#define CONFIG_BT_MRVL_SDIO 1
+#endif /* CONFIG_BT_MRVL_SDIO */ 
+#if defined(CONFIG_COMPAT_STAGING) || defined(CONFIG_COMPAT_STAGING_MODULE)
+#if defined(CONFIG_WIRELESS_EXT) || defined(CONFIG_WIRELESS_EXT_MODULE)
+#ifndef CONFIG_ATH6KL_ENABLE_TARGET_DEBUG_PRINTS
+#define CONFIG_ATH6KL_ENABLE_TARGET_DEBUG_PRINTS 1
+#endif /* CONFIG_ATH6KL_ENABLE_TARGET_DEBUG_PRINTS */ 
+#ifndef CONFIG_ATH6KL_VIRTUAL_SCATTER_GATHER
+#define CONFIG_ATH6KL_VIRTUAL_SCATTER_GATHER 1
+#endif /* CONFIG_ATH6KL_VIRTUAL_SCATTER_GATHER */ 
+#ifndef CONFIG_ATH6K_LEGACY
+#define CONFIG_ATH6K_LEGACY 1
+#endif /* CONFIG_ATH6K_LEGACY */ 
+#ifndef CONFIG_BRCMFMAC
+#define CONFIG_BRCMFMAC 1
+#endif /* CONFIG_BRCMFMAC */ 
+#endif /* CONFIG_WIRELESS_EXT */
+#endif /* CONFIG_COMPAT_STAGING */
+#endif /* CONFIG_MMC */
+#ifndef CONFIG_RTLWIFI
+#define CONFIG_RTLWIFI 1
+#endif /* CONFIG_RTLWIFI */ 
+#ifndef CONFIG_RTL8192C_COMMON
+#define CONFIG_RTL8192C_COMMON 1
+#endif /* CONFIG_RTL8192C_COMMON */ 
+#ifndef CONFIG_RT2X00
+#define CONFIG_RT2X00 1
+#endif /* CONFIG_RT2X00 */ 
+#ifndef CONFIG_RT2X00_LIB
+#define CONFIG_RT2X00_LIB 1
+#endif /* CONFIG_RT2X00_LIB */ 
+#ifndef CONFIG_RT2800_LIB
+#define CONFIG_RT2800_LIB 1
+#endif /* CONFIG_RT2800_LIB */ 
+#ifndef CONFIG_RT2X00_LIB_FIRMWARE
+#define CONFIG_RT2X00_LIB_FIRMWARE 1
+#endif /* CONFIG_RT2X00_LIB_FIRMWARE */ 
+#ifndef CONFIG_RT2X00_LIB_CRYPTO
+#define CONFIG_RT2X00_LIB_CRYPTO 1
+#endif /* CONFIG_RT2X00_LIB_CRYPTO */ 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25))
+#undef CONFIG_RT2X00_LIB_LEDS
+#else /* CONFIG_COMPAT_KERNEL_25 */
+#if defined(CONFIG_LEDS_CLASS) || defined(CONFIG_LEDS_CLASS_MODULE)
+#ifndef CONFIG_RT2X00_LIB_LEDS
+#define CONFIG_RT2X00_LIB_LEDS 1
+#endif /* CONFIG_RT2X00_LIB_LEDS */ 
+#endif /* CONFIG_LEDS_CLASS */
+#endif /* CONFIG_COMPAT_KERNEL_25 */
+#ifndef CONFIG_P54_COMMON
+#define CONFIG_P54_COMMON 1
+#endif /* CONFIG_P54_COMMON */ 
+#if defined(CONFIG_MAC80211_LEDS) || defined(CONFIG_MAC80211_LEDS_MODULE)
+#ifndef CONFIG_P54_LEDS
+#define CONFIG_P54_LEDS 1
+#endif /* CONFIG_P54_LEDS */ 
+#endif /* CONFIG_MAC80211_LEDS */
+#ifndef CONFIG_ATH_COMMON
+#define CONFIG_ATH_COMMON 1
+#endif /* CONFIG_ATH_COMMON */ 
+#if defined(CONFIG_COMPAT_STAGING) || defined(CONFIG_COMPAT_STAGING_MODULE)
+#ifndef CONFIG_BRCMUTIL
+#define CONFIG_BRCMUTIL 1
+#endif /* CONFIG_BRCMUTIL */ 
+#endif /* CONFIG_COMPAT_STAGING */
+#if defined(CONFIG_CRC7) || defined(CONFIG_CRC7_MODULE)
+#ifndef CONFIG_WL1251
+#define CONFIG_WL1251 1
+#endif /* CONFIG_WL1251 */ 
+#ifndef CONFIG_WL12XX
+#define CONFIG_WL12XX 1
+#endif /* CONFIG_WL12XX */ 
+#ifndef CONFIG_WL12XX_HT
+#define CONFIG_WL12XX_HT 1
+#endif /* CONFIG_WL12XX_HT */ 
+#endif /* CONFIG_CRC7 */
+#ifndef CONFIG_MWIFIEX
+#define CONFIG_MWIFIEX 1
+#endif /* CONFIG_MWIFIEX */ 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+#undef CONFIG_LIBERTAS
+#else /* CONFIG_COMPAT_KERNEL_27 */
+#ifndef CONFIG_LIBERTAS_THINFIRM
+#define CONFIG_LIBERTAS_THINFIRM 1
+#endif /* CONFIG_LIBERTAS_THINFIRM */ 
+#ifndef CONFIG_LIBERTAS
+#define CONFIG_LIBERTAS 1
+#endif /* CONFIG_LIBERTAS */ 
+#ifndef CONFIG_LIBERTAS_MESH
+#define CONFIG_LIBERTAS_MESH 1
+#endif /* CONFIG_LIBERTAS_MESH */ 
+#endif /* CONFIG_COMPAT_KERNEL_27 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31))
+#ifndef CONFIG_RFKILL_BACKPORT
+#define CONFIG_RFKILL_BACKPORT 1
+#endif /* CONFIG_RFKILL_BACKPORT */ 
+#if defined(CONFIG_LEDS_TRIGGERS) || defined(CONFIG_LEDS_TRIGGERS_MODULE)
+#ifndef CONFIG_RFKILL_BACKPORT_LEDS
+#define CONFIG_RFKILL_BACKPORT_LEDS 1
+#endif /* CONFIG_RFKILL_BACKPORT_LEDS */ 
+#endif /* CONFIG_LEDS_TRIGGERS */
+#endif /* CONFIG_COMPAT_KERNEL_31 */
+#ifdef CONFIG_NET_SCHED
+#ifdef CONFIG_NETDEVICES_MULTIQUEUE
+#ifndef CONFIG_MAC80211_QOS
+#define CONFIG_MAC80211_QOS 1
+#endif /* CONFIG_MAC80211_QOS */ 
+#endif
+#endif
 #endif /* COMPAT_AUTOCONF_INCLUDED */
diff -rNu a/include/linux/cordic.h b/include/linux/cordic.h
--- a/include/linux/cordic.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/cordic.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2011 Broadcom Corporation
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-#ifndef __CORDIC_H_
-#define __CORDIC_H_
-
-#include <linux/types.h>
-
-/**
- * struct cordic_iq - i/q coordinate.
- *
- * @i: real part of coordinate (in phase).
- * @q: imaginary part of coordinate (quadrature).
- */
-struct cordic_iq {
-	s32 i;
-	s32 q;
-};
-
-/**
- * cordic_calc_iq() - calculates the i/q coordinate for given angle.
- *
- * @theta: angle in degrees for which i/q coordinate is to be calculated.
- * @coord: function output parameter holding the i/q coordinate.
- *
- * The function calculates the i/q coordinate for a given angle using
- * cordic algorithm. The coordinate consists of a real (i) and an
- * imaginary (q) part. The real part is essentially the cosine of the
- * angle and the imaginary part is the sine of the angle. The returned
- * values are scaled by 2^16 for precision. The range for theta is
- * for -180 degrees to +180 degrees. Passed values outside this range are
- * converted before doing the actual calculation.
- */
-struct cordic_iq cordic_calc_iq(s32 theta);
-
-#endif /* __CORDIC_H_ */
diff -rNu a/include/linux/crc8.h b/include/linux/crc8.h
--- a/include/linux/crc8.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/crc8.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,101 +0,0 @@
-/*
- * Copyright (c) 2011 Broadcom Corporation
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-#ifndef __CRC8_H_
-#define __CRC8_H_
-
-#include <linux/types.h>
-
-/* see usage of this value in crc8() description */
-#define CRC8_INIT_VALUE		0xFF
-
-/*
- * Return value of crc8() indicating valid message+crc. This is true
- * if a CRC is inverted before transmission. The CRC computed over the
- * whole received bitstream is _table[x], where x is the bit pattern
- * of the modification (almost always 0xff).
- */
-#define CRC8_GOOD_VALUE(_table)	(_table[0xFF])
-
-/* required table size for crc8 algorithm */
-#define CRC8_TABLE_SIZE			256
-
-/* helper macro assuring right table size is used */
-#define DECLARE_CRC8_TABLE(_table) \
-	static u8 _table[CRC8_TABLE_SIZE]
-
-/**
- * crc8_populate_lsb - fill crc table for given polynomial in regular bit order.
- *
- * @table:	table to be filled.
- * @polynomial:	polynomial for which table is to be filled.
- *
- * This function fills the provided table according the polynomial provided for
- * regular bit order (lsb first). Polynomials in CRC algorithms are typically
- * represented as shown below.
- *
- *	poly = x^8 + x^7 + x^6 + x^4 + x^2 + 1
- *
- * For lsb first direction x^7 maps to the lsb. So the polynomial is as below.
- *
- * - lsb first: poly = 10101011(1) = 0xAB
- */
-void crc8_populate_lsb(u8 table[CRC8_TABLE_SIZE], u8 polynomial);
-
-/**
- * crc8_populate_msb - fill crc table for given polynomial in reverse bit order.
- *
- * @table:	table to be filled.
- * @polynomial:	polynomial for which table is to be filled.
- *
- * This function fills the provided table according the polynomial provided for
- * reverse bit order (msb first). Polynomials in CRC algorithms are typically
- * represented as shown below.
- *
- *	poly = x^8 + x^7 + x^6 + x^4 + x^2 + 1
- *
- * For msb first direction x^7 maps to the msb. So the polynomial is as below.
- *
- * - msb first: poly = (1)11010101 = 0xD5
- */
-void crc8_populate_msb(u8 table[CRC8_TABLE_SIZE], u8 polynomial);
-
-/**
- * crc8() - calculate a crc8 over the given input data.
- *
- * @table:	crc table used for calculation.
- * @pdata:	pointer to data buffer.
- * @nbytes:	number of bytes in data buffer.
- * @crc:	previous returned crc8 value.
- *
- * The CRC8 is calculated using the polynomial given in crc8_populate_msb()
- * or crc8_populate_lsb().
- *
- * The caller provides the initial value (either %CRC8_INIT_VALUE
- * or the previous returned value) to allow for processing of
- * discontiguous blocks of data.  When generating the CRC the
- * caller is responsible for complementing the final return value
- * and inserting it into the byte stream.  When validating a byte
- * stream (including CRC8), a final return value of %CRC8_GOOD_VALUE
- * indicates the byte stream data can be considered valid.
- *
- * Reference:
- * "A Painless Guide to CRC Error Detection Algorithms", ver 3, Aug 1993
- * Williams, Ross N., ross<at>ross.net
- * (see URL http://www.ross.net/crc/download/crc_v3.txt).
- */
-u8 crc8(const u8 table[CRC8_TABLE_SIZE], u8 *pdata, size_t nbytes, u8 crc);
-
-#endif /* __CRC8_H_ */
diff -rNu a/include/linux/export.h b/include/linux/export.h
--- a/include/linux/export.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/export.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,12 +0,0 @@
-#ifndef _COMPAT_LINUX_EXPORT_H
-#define _COMPAT_LINUX_EXPORT_H 1
-
-#include <linux/version.h>
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
-#include_next <linux/export.h>
-#else
-#include <linux/module.h>
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0)) */
-
-#endif	/* _COMPAT_LINUX_EXPORT_H */
diff -rNu a/include/linux/nl80211.h b/include/linux/nl80211.h
--- a/include/linux/nl80211.h	2012-03-23 12:18:25.000000000 +0200
+++ b/include/linux/nl80211.h	2011-12-20 18:29:49.000000000 +0200
@@ -231,6 +231,8 @@
  *
  * @NL80211_CMD_GET_SCAN: get scan results
  * @NL80211_CMD_TRIGGER_SCAN: trigger a new scan with the given parameters
+ *	%NL80211_ATTR_TX_NO_CCK_RATE is used to decide whether to send the
+ *	probe requests at CCK rate or not.
  * @NL80211_CMD_NEW_SCAN_RESULTS: scan notification (as a reply to
  *	NL80211_CMD_GET_SCAN and on the "scan" multicast group)
  * @NL80211_CMD_SCAN_ABORTED: scan was aborted, for unspecified reasons,
@@ -424,6 +426,8 @@
  *	specified using %NL80211_ATTR_DURATION. When called, this operation
  *	returns a cookie (%NL80211_ATTR_COOKIE) that will be included with the
  *	TX status event pertaining to the TX request.
+ *	%NL80211_ATTR_TX_NO_CCK_RATE is used to decide whether to send the
+ *	management frames at CCK rate or not in 2GHz band.
  * @NL80211_CMD_FRAME_WAIT_CANCEL: When an off-channel TX was requested, this
  *	command may be used with the corresponding cookie to cancel the wait
  *	time if it is known that it is no longer necessary.
@@ -999,6 +1003,20 @@
  * @NL80211_ATTR_STA_WME: Nested attribute containing the wme configuration
  *	of the station, see &enum nl80211_sta_wme_attr.
  *
+ * @NL80211_ATTR_SCAN_SUPP_RATES: rates per to be advertised as supported in scan,
+ *	nested array attribute containing an entry for each band, with the entry
+ *	being a list of supported rates as defined by IEEE 802.11 7.3.2.2 but
+ *	without the length restriction (at most %NL80211_MAX_SUPP_RATES).
+ *
+ * @NL80211_ATTR_TX_NO_CCK_RATE: Indicates whether to use CCK rate or not
+ *	for management frames transmission. In order to avoid p2p probe/action
+ *	frames are being transmitted at CCK rate in 2GHz band, the user space
+ *	applications use this attribute.
+ *	This attribute is used with %NL80211_CMD_TRIGGER_SCAN and
+ *	%NL80211_CMD_FRAME commands.
+ *
+ * @NL80211_ATTR_PROBE_RESP: Probe Response template data
+ *
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
  */
@@ -1198,6 +1216,12 @@
 	NL80211_ATTR_SOFTWARE_IFTYPES,
 
 	NL80211_ATTR_STA_WME,
+	NL80211_ATTR_SCAN_SUPP_RATES,
+
+	NL80211_ATTR_TX_NO_CCK_RATE,
+
+	NL80211_ATTR_PROBE_RESP,
+
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
diff -rNu a/include/linux/pm_qos.h b/include/linux/pm_qos.h
--- a/include/linux/pm_qos.h	2012-03-23 07:36:24.000000000 +0200
+++ b/include/linux/pm_qos.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,12 +0,0 @@
-#ifndef _COMPAT_LINUX_PM_QOS_H
-#define _COMPAT_LINUX_PM_QOS_H 1
-
-#include <linux/version.h>
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
-#include_next <linux/pm_qos.h>
-#else
-#include <linux/pm_qos_params.h>
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0)) */
-
-#endif	/* _COMPAT_LINUX_PM_QOS_H */
diff -rNu a/include/net/cfg80211.h b/include/net/cfg80211.h
--- a/include/net/cfg80211.h	2012-03-23 12:18:25.000000000 +0200
+++ b/include/net/cfg80211.h	2011-12-20 18:29:49.000000000 +0200
@@ -657,6 +657,8 @@
  * @ssid_len: length of ssid string
  *	(>0 = ssid_len, -1 = do not change)
  * @ssid: SSID string (for AP mode). NULL termination not required.
+ * @probe_resp_len: length of probe response template (@probe_resp)
+ * @probe_resp: probe response template (AP mode only)
  */
 struct bss_parameters {
 	int use_cts_prot;
@@ -668,6 +670,8 @@
 	int ht_opmode;
 	int ssid_len;
 	u8 *ssid;
+	int probe_resp_len;
+	u8 *probe_resp;
 };
 
 /*
@@ -784,9 +788,11 @@
  * @n_channels: total number of channels to scan
  * @ie: optional information element(s) to add into Probe Request or %NULL
  * @ie_len: length of ie in octets
+ * @rates: bitmap of rates to advertise for each band
  * @wiphy: the wiphy this was for
  * @dev: the interface
  * @aborted: (internal) scan request was notified as aborted
+ * @no_cck: used to send probe requests at non CCK rate in 2GHz band
  */
 struct cfg80211_scan_request {
 	struct cfg80211_ssid *ssids;
@@ -795,10 +801,13 @@
 	const u8 *ie;
 	size_t ie_len;
 
+	u32 rates[IEEE80211_NUM_BANDS];
+
 	/* internal */
 	struct wiphy *wiphy;
 	struct net_device *dev;
 	bool aborted;
+	bool no_cck;
 
 	/* keep last */
 	struct ieee80211_channel *channels[0];
@@ -1470,7 +1479,8 @@
 			  struct ieee80211_channel *chan, bool offchan,
 			  enum nl80211_channel_type channel_type,
 			  bool channel_type_valid, unsigned int wait,
-			  const u8 *buf, size_t len, u64 *cookie);
+			  const u8 *buf, size_t len, bool no_cck,
+			  u64 *cookie);
 	int	(*mgmt_tx_cancel_wait)(struct wiphy *wiphy,
 				       struct net_device *dev,
 				       u64 cookie);
diff -rNu a/include/net/mac80211.h b/include/net/mac80211.h
--- a/include/net/mac80211.h	2012-03-23 12:18:25.000000000 +0200
+++ b/include/net/mac80211.h	2011-12-20 18:29:49.000000000 +0200
@@ -165,6 +165,7 @@
  *	that it is only ever disabled for station mode.
  * @BSS_CHANGED_IDLE: Idle changed for this BSS/interface.
  * @BSS_CHANGED_SSID: SSID changed for this BSS (AP mode)
+ * @BSS_CHANGED_AP_PROBE_RESP: Probe Response changed for this BSS (AP mode)
  */
 enum ieee80211_bss_change {
 	BSS_CHANGED_ASSOC		= 1<<0,
@@ -183,6 +184,7 @@
 	BSS_CHANGED_QOS			= 1<<13,
 	BSS_CHANGED_IDLE		= 1<<14,
 	BSS_CHANGED_SSID		= 1<<15,
+	BSS_CHANGED_AP_PROBE_RESP	= 1<<16,
 
 	/* when adding here, make sure to change ieee80211_reconfig */
 };
@@ -350,6 +352,9 @@
  * @IEEE80211_TX_INTFL_TKIP_MIC_FAILURE: Marks this packet to be used for TKIP
  *	testing. It will be sent out with incorrect Michael MIC key to allow
  *	TKIP countermeasures to be tested.
+ * @IEEE80211_TX_CTL_NO_CCK_RATE: This frame will be sent at non CCK rate.
+ *	This flag is actually used for management frame especially for P2P
+ *	frames not being sent at CCK rate in 2GHz band.
  *
  * Note: If you have to add new flags to the enumeration, then don't
  *	 forget to update %IEEE80211_TX_TEMPORARY_FLAGS when necessary.
@@ -380,6 +385,7 @@
 	IEEE80211_TX_CTL_STBC			= BIT(23) | BIT(24),
 	IEEE80211_TX_CTL_TX_OFFCHAN		= BIT(25),
 	IEEE80211_TX_INTFL_TKIP_MIC_FAILURE	= BIT(26),
+	IEEE80211_TX_CTL_NO_CCK_RATE		= BIT(27),
 };
 
 #define IEEE80211_TX_CTL_STBC_SHIFT		23
@@ -2422,6 +2428,19 @@
 }
 
 /**
+ * ieee80211_proberesp_get - retrieve a Probe Response template
+ * @hw: pointer obtained from ieee80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * Creates a Probe Response template which can, for example, be uploaded to
+ * hardware. The destination address should be set by the caller.
+ *
+ * Can only be called in AP mode.
+ */
+struct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,
+					struct ieee80211_vif *vif);
+
+/**
  * ieee80211_pspoll_get - retrieve a PS Poll template
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
diff -rNu a/net/mac80211/cfg.c b/net/mac80211/cfg.c
--- a/net/mac80211/cfg.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/mac80211/cfg.c	2011-12-20 18:29:49.000000000 +0200
@@ -1167,6 +1167,34 @@
 }
 #endif
 
+static int ieee80211_set_probe_resp(struct ieee80211_sub_if_data *sdata,
+				    u8 *resp, size_t resp_len)
+{
+	struct sk_buff *new, *old;
+
+	old = sdata->u.ap.probe_resp;
+
+	if (!resp || !resp_len)
+		return -EINVAL;
+
+	new = dev_alloc_skb(resp_len);
+	if (!new) {
+		printk(KERN_DEBUG "%s: failed to allocate buffer for probe "
+		       "response template\n", sdata->name);
+		return -ENOMEM;
+	}
+
+	memcpy(skb_put(new, resp_len), resp, resp_len);
+
+	rcu_assign_pointer(sdata->u.ap.probe_resp, new);
+	synchronize_rcu();
+
+	if (old)
+		dev_kfree_skb(old);
+
+	return 0;
+}
+
 static int ieee80211_change_bss(struct wiphy *wiphy,
 				struct net_device *dev,
 				struct bss_parameters *params)
@@ -1236,6 +1264,13 @@
 		changed |= BSS_CHANGED_SSID;
 	}
 
+	if (params->probe_resp_len > 0) {
+		int ret = ieee80211_set_probe_resp(sdata, params->probe_resp,
+						   params->probe_resp_len);
+		if (!ret)
+			changed |= BSS_CHANGED_AP_PROBE_RESP;
+	}
+
 	ieee80211_bss_info_change_notify(sdata, changed);
 
 	return 0;
@@ -1827,7 +1862,8 @@
 			     struct ieee80211_channel *chan, bool offchan,
 			     enum nl80211_channel_type channel_type,
 			     bool channel_type_valid, unsigned int wait,
-			     const u8 *buf, size_t len, u64 *cookie)
+			     const u8 *buf, size_t len, bool no_cck,
+			     u64 *cookie)
 {
 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
 	struct ieee80211_local *local = sdata->local;
@@ -1854,6 +1890,9 @@
 		flags |= IEEE80211_TX_CTL_TX_OFFCHAN;
 	}
 
+	if (no_cck)
+		flags |= IEEE80211_TX_CTL_NO_CCK_RATE;
+
 	if (is_offchan && !offchan)
 		return -EBUSY;
 
diff -rNu a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
--- a/net/mac80211/ieee80211_i.h	2012-03-23 12:18:25.000000000 +0200
+++ b/net/mac80211/ieee80211_i.h	2011-12-20 18:29:49.000000000 +0200
@@ -215,6 +215,7 @@
 
 struct ieee80211_if_ap {
 	struct beacon_data __rcu *beacon;
+	struct sk_buff __rcu *probe_resp;
 
 	struct list_head vlans;
 
@@ -1358,12 +1359,13 @@
 			     enum ieee80211_band band, u32 rate_mask,
 			     u8 channel);
 struct sk_buff *ieee80211_build_probe_req(struct ieee80211_sub_if_data *sdata,
-					  u8 *dst,
+					  u8 *dst, u32 ratemask,
 					  const u8 *ssid, size_t ssid_len,
 					  const u8 *ie, size_t ie_len);
 void ieee80211_send_probe_req(struct ieee80211_sub_if_data *sdata, u8 *dst,
 			      const u8 *ssid, size_t ssid_len,
-			      const u8 *ie, size_t ie_len);
+			      const u8 *ie, size_t ie_len,
+			      u32 ratemask, bool no_cck);
 
 void ieee80211_sta_def_wmm_params(struct ieee80211_sub_if_data *sdata,
 				  const size_t supp_rates_len,
diff -rNu a/net/mac80211/iface.c b/net/mac80211/iface.c
--- a/net/mac80211/iface.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/mac80211/iface.c	2011-12-20 18:29:49.000000000 +0200
@@ -456,15 +456,19 @@
 		struct ieee80211_sub_if_data *vlan, *tmpsdata;
 		struct beacon_data *old_beacon =
 			rtnl_dereference(sdata->u.ap.beacon);
+		struct sk_buff *old_probe_resp =
+			rtnl_dereference(sdata->u.ap.probe_resp);
 
 		/* sdata_running will return false, so this will disable */
 		ieee80211_bss_info_change_notify(sdata,
 						 BSS_CHANGED_BEACON_ENABLED);
 
-		/* remove beacon */
+		/* remove beacon and probe response */
 		rcu_assign_pointer(sdata->u.ap.beacon, NULL);
+		rcu_assign_pointer(sdata->u.ap.probe_resp, NULL);
 		synchronize_rcu();
 		kfree(old_beacon);
+		kfree(old_probe_resp);
 
 		/* free all potentially still buffered bcast frames */
 		while ((skb = skb_dequeue(&sdata->u.ap.ps_bc_buf))) {
diff -rNu a/net/mac80211/mlme.c b/net/mac80211/mlme.c
--- a/net/mac80211/mlme.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/mac80211/mlme.c	2011-12-20 18:29:49.000000000 +0200
@@ -1237,7 +1237,8 @@
 		ieee80211_send_nullfunc(sdata->local, sdata, 0);
 	} else {
 		ssid = ieee80211_bss_get_ie(ifmgd->associated, WLAN_EID_SSID);
-		ieee80211_send_probe_req(sdata, dst, ssid + 2, ssid[1], NULL, 0);
+		ieee80211_send_probe_req(sdata, dst, ssid + 2, ssid[1], NULL, 0,
+					 (u32) -1, false);
 	}
 
 	ifmgd->probe_send_count++;
@@ -1322,7 +1323,8 @@
 
 	ssid = ieee80211_bss_get_ie(ifmgd->associated, WLAN_EID_SSID);
 	skb = ieee80211_build_probe_req(sdata, ifmgd->associated->bssid,
-					ssid + 2, ssid[1], NULL, 0);
+					(u32) -1, ssid + 2, ssid[1],
+					NULL, 0);
 
 	return skb;
 }
diff -rNu a/net/mac80211/modules.order b/net/mac80211/modules.order
--- a/net/mac80211/modules.order	1970-01-01 02:00:00.000000000 +0200
+++ b/net/mac80211/modules.order	2011-12-20 18:29:49.000000000 +0200
@@ -0,0 +1 @@
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/net/mac80211/mac80211.ko
diff -rNu a/net/mac80211/rate.c b/net/mac80211/rate.c
--- a/net/mac80211/rate.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/mac80211/rate.c	2011-12-20 18:29:49.000000000 +0200
@@ -233,6 +233,27 @@
 	/* could not find a basic rate; use original selection */
 }
 
+static inline s8
+rate_lowest_non_cck_index(struct ieee80211_supported_band *sband,
+			  struct ieee80211_sta *sta)
+{
+	int i;
+
+	for (i = 0; i < sband->n_bitrates; i++) {
+		struct ieee80211_rate *srate = &sband->bitrates[i];
+		if ((srate->bitrate == 10) || (srate->bitrate == 20) ||
+		    (srate->bitrate == 55) || (srate->bitrate == 110))
+			continue;
+
+		if (rate_supported(sta, sband->band, i))
+			return i;
+	}
+
+	/* No matching rate found */
+	return 0;
+}
+
+
 bool rate_control_send_low(struct ieee80211_sta *sta,
 			   void *priv_sta,
 			   struct ieee80211_tx_rate_control *txrc)
@@ -242,7 +263,13 @@
 	int mcast_rate;
 
 	if (!sta || !priv_sta || rc_no_data_or_no_ack(txrc)) {
-		info->control.rates[0].idx = rate_lowest_index(txrc->sband, sta);
+		if ((sband->band != IEEE80211_BAND_2GHZ) ||
+		    !(info->flags & IEEE80211_TX_CTL_NO_CCK_RATE))
+			info->control.rates[0].idx =
+				rate_lowest_index(txrc->sband, sta);
+		else
+			info->control.rates[0].idx =
+				rate_lowest_non_cck_index(txrc->sband, sta);
 		info->control.rates[0].count =
 			(info->flags & IEEE80211_TX_CTL_NO_ACK) ?
 			1 : txrc->hw->max_rate_tries;
diff -rNu a/net/mac80211/rx.c b/net/mac80211/rx.c
--- a/net/mac80211/rx.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/mac80211/rx.c	2011-12-20 18:29:49.000000000 +0200
@@ -2690,7 +2690,9 @@
 		} else if (!ieee80211_bssid_match(bssid,
 					sdata->vif.addr)) {
 			if (!(status->rx_flags & IEEE80211_RX_IN_SCAN) &&
-			    !ieee80211_is_beacon(hdr->frame_control))
+			    !ieee80211_is_beacon(hdr->frame_control) &&
+			    !(ieee80211_is_action(hdr->frame_control) &&
+			      sdata->vif.p2p))
 				return 0;
 			status->rx_flags &= ~IEEE80211_RX_RA_MATCH;
 		}
diff -rNu a/net/mac80211/scan.c b/net/mac80211/scan.c
--- a/net/mac80211/scan.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/mac80211/scan.c	2011-12-20 18:29:49.000000000 +0200
@@ -252,8 +252,8 @@
 	local->hw_scan_req->n_channels = n_chans;
 
 	ielen = ieee80211_build_preq_ies(local, (u8 *)local->hw_scan_req->ie,
-					 req->ie, req->ie_len, band, (u32) -1,
-					 0);
+					 req->ie, req->ie_len, band,
+					 req->rates[band], 0);
 	local->hw_scan_req->ie_len = ielen;
 
 	return true;
@@ -415,6 +415,7 @@
 			req->n_channels * sizeof(req->channels[0]);
 		local->hw_scan_req->ie = ies;
 
+		local->hw_scan_req->no_cck = req->no_cck;
 		local->hw_scan_band = 0;
 
 		/*
@@ -653,13 +654,16 @@
 {
 	int i;
 	struct ieee80211_sub_if_data *sdata = local->scan_sdata;
+	enum ieee80211_band band = local->hw.conf.channel->band;
 
 	for (i = 0; i < local->scan_req->n_ssids; i++)
 		ieee80211_send_probe_req(
 			sdata, NULL,
 			local->scan_req->ssids[i].ssid,
 			local->scan_req->ssids[i].ssid_len,
-			local->scan_req->ie, local->scan_req->ie_len);
+			local->scan_req->ie, local->scan_req->ie_len,
+			local->scan_req->rates[band],
+			local->scan_req->no_cck);
 
 	/*
 	 * After sending probe requests, wait for probe responses
diff -rNu a/net/mac80211/tx.c b/net/mac80211/tx.c
--- a/net/mac80211/tx.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/mac80211/tx.c	2011-12-20 18:29:49.000000000 +0200
@@ -2326,6 +2326,37 @@
 }
 EXPORT_SYMBOL(ieee80211_beacon_get_tim);
 
+struct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,
+					struct ieee80211_vif *vif)
+{
+	struct ieee80211_if_ap *ap = NULL;
+	struct sk_buff *presp = NULL, *skb = NULL;
+	struct ieee80211_hdr *hdr;
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+
+	if (sdata->vif.type != NL80211_IFTYPE_AP)
+		return NULL;
+
+	rcu_read_lock();
+
+	ap = &sdata->u.ap;
+	presp = rcu_dereference(ap->probe_resp);
+	if (!presp)
+		goto out;
+
+	skb = skb_copy(presp, GFP_ATOMIC);
+	if (!skb)
+		goto out;
+
+	hdr = (struct ieee80211_hdr *) skb->data;
+	memset(hdr->addr1, 0, sizeof(hdr->addr1));
+
+out:
+	rcu_read_unlock();
+	return skb;
+}
+EXPORT_SYMBOL(ieee80211_proberesp_get);
+
 struct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,
 				     struct ieee80211_vif *vif)
 {
diff -rNu a/net/mac80211/util.c b/net/mac80211/util.c
--- a/net/mac80211/util.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/mac80211/util.c	2011-12-20 18:29:49.000000000 +0200
@@ -929,12 +929,6 @@
 	ieee80211_tx_skb(sdata, skb);
 }
 
-static inline bool is_11b_bitrate(u16 bitrate)
-{
-	return (bitrate == 10 || bitrate == 20 || bitrate == 55 ||
-		bitrate == 110);
-}
-
 int ieee80211_build_preq_ies(struct ieee80211_local *local, u8 *buffer,
 			     const u8 *ie, size_t ie_len,
 			     enum ieee80211_band band, u32 rate_mask,
@@ -947,21 +941,15 @@
 	u8 rates[32];
 	int num_rates;
 	int ext_rates_len;
-	bool is_p2p;
 
 	sband = local->hw.wiphy->bands[band];
 
 	pos = buffer;
 
-	is_p2p = !!cfg80211_find_vendor_ie(WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P,
-					   ie, ie_len);
-
 	num_rates = 0;
 	for (i = 0; i < sband->n_bitrates; i++) {
 		if ((BIT(i) & rate_mask) == 0)
 			continue; /* skip rate */
-		if (is_p2p && is_11b_bitrate(sband->bitrates[i].bitrate))
-			continue;
 		rates[num_rates++] = (u8) (sband->bitrates[i].bitrate / 5);
 	}
 
@@ -1054,7 +1042,7 @@
 }
 
 struct sk_buff *ieee80211_build_probe_req(struct ieee80211_sub_if_data *sdata,
-					  u8 *dst,
+					  u8 *dst, u32 ratemask,
 					  const u8 *ssid, size_t ssid_len,
 					  const u8 *ie, size_t ie_len)
 {
@@ -1078,9 +1066,7 @@
 
 	buf_len = ieee80211_build_preq_ies(local, buf, ie, ie_len,
 					   local->hw.conf.channel->band,
-					   sdata->rc_rateidx_mask
-					   [local->hw.conf.channel->band],
-					   chan);
+					   ratemask, chan);
 
 	skb = ieee80211_probereq_get(&local->hw, &sdata->vif,
 				     ssid, ssid_len,
@@ -1100,13 +1086,19 @@
 
 void ieee80211_send_probe_req(struct ieee80211_sub_if_data *sdata, u8 *dst,
 			      const u8 *ssid, size_t ssid_len,
-			      const u8 *ie, size_t ie_len)
+			      const u8 *ie, size_t ie_len,
+			      u32 ratemask, bool no_cck)
 {
 	struct sk_buff *skb;
 
-	skb = ieee80211_build_probe_req(sdata, dst, ssid, ssid_len, ie, ie_len);
-	if (skb)
+	skb = ieee80211_build_probe_req(sdata, dst, ratemask, ssid, ssid_len,
+					ie, ie_len);
+	if (skb) {
+		if (no_cck)
+			IEEE80211_SKB_CB(skb)->flags |=
+				IEEE80211_TX_CTL_NO_CCK_RATE;
 		ieee80211_tx_skb(sdata, skb);
+	}
 }
 
 u32 ieee80211_sta_get_rates(struct ieee80211_local *local,
@@ -1273,7 +1265,8 @@
 			changed |= BSS_CHANGED_IBSS;
 			/* fall through */
 		case NL80211_IFTYPE_AP:
-			changed |= BSS_CHANGED_SSID;
+			changed |= BSS_CHANGED_SSID |
+				   BSS_CHANGED_AP_PROBE_RESP;
 			/* fall through */
 		case NL80211_IFTYPE_MESH_POINT:
 			changed |= BSS_CHANGED_BEACON |
diff -rNu a/net/mac80211/work.c b/net/mac80211/work.c
--- a/net/mac80211/work.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/mac80211/work.c	2011-12-20 18:29:49.000000000 +0200
@@ -458,7 +458,8 @@
 	 * will not answer to direct packet in unassociated state.
 	 */
 	ieee80211_send_probe_req(sdata, NULL, wk->probe_auth.ssid,
-				 wk->probe_auth.ssid_len, NULL, 0);
+				 wk->probe_auth.ssid_len, NULL, 0,
+				 (u32) -1, false);
 
 	wk->timeout = jiffies + IEEE80211_AUTH_TIMEOUT;
 	run_again(local, wk->timeout);
diff -rNu a/net/wireless/core.c b/net/wireless/core.c
--- a/net/wireless/core.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/wireless/core.c	2011-12-20 18:29:49.000000000 +0200
@@ -4,7 +4,9 @@
  * Copyright 2006-2010		Johannes Berg <johannes@sipsolutions.net>
  */
 
+#ifndef pr_fmt
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#endif
 
 #include <linux/if.h>
 #include <linux/module.h>
@@ -636,7 +638,7 @@
 	if (!rdev->ops->rfkill_poll)
 		return;
 	rdev->rfkill_ops.poll = cfg80211_rfkill_poll;
-	rfkill_resume_polling(rdev->rfkill);
+	//rfkill_resume_polling(rdev->rfkill);
 }
 EXPORT_SYMBOL(wiphy_rfkill_start_polling);
 
diff -rNu a/net/wireless/core.h b/net/wireless/core.h
--- a/net/wireless/core.h	2012-03-23 12:18:25.000000000 +0200
+++ b/net/wireless/core.h	2011-12-20 18:29:49.000000000 +0200
@@ -375,7 +375,8 @@
 			  struct ieee80211_channel *chan, bool offchan,
 			  enum nl80211_channel_type channel_type,
 			  bool channel_type_valid, unsigned int wait,
-			  const u8 *buf, size_t len, u64 *cookie);
+			  const u8 *buf, size_t len, bool no_cck,
+			  u64 *cookie);
 
 /* SME */
 int __cfg80211_connect(struct cfg80211_registered_device *rdev,
@@ -445,6 +446,10 @@
 
 u16 cfg80211_calculate_bitrate(struct rate_info *rate);
 
+int ieee80211_get_ratemask(struct ieee80211_supported_band *sband,
+			   const u8 *rates, unsigned int n_rates,
+			   u32 *mask);
+
 int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
 				 u32 beacon_int);
 
diff -rNu a/net/wireless/mlme.c b/net/wireless/mlme.c
--- a/net/wireless/mlme.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/wireless/mlme.c	2011-12-20 18:29:49.000000000 +0200
@@ -898,7 +898,8 @@
 			  struct ieee80211_channel *chan, bool offchan,
 			  enum nl80211_channel_type channel_type,
 			  bool channel_type_valid, unsigned int wait,
-			  const u8 *buf, size_t len, u64 *cookie)
+			  const u8 *buf, size_t len, bool no_cck,
+			  u64 *cookie)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	const struct ieee80211_mgmt *mgmt;
@@ -989,7 +990,7 @@
 	/* Transmit the Action frame as requested by user space */
 	return rdev->ops->mgmt_tx(&rdev->wiphy, dev, chan, offchan,
 				  channel_type, channel_type_valid,
-				  wait, buf, len, cookie);
+				  wait, buf, len, no_cck, cookie);
 }
 
 bool cfg80211_rx_mgmt(struct net_device *dev, int freq, const u8 *buf,
diff -rNu a/net/wireless/modules.order b/net/wireless/modules.order
--- a/net/wireless/modules.order	1970-01-01 02:00:00.000000000 +0200
+++ b/net/wireless/modules.order	2011-12-20 18:29:49.000000000 +0200
@@ -0,0 +1 @@
+kernel//home/CORPUSERS/xp004891/repos/ginger-mogami-r4/vendor/ti/wlan/compat-wireless-wl12xx/net/wireless/cfg80211.ko
diff -rNu a/net/wireless/nl80211.c b/net/wireless/nl80211.c
--- a/net/wireless/nl80211.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/wireless/nl80211.c	2011-12-20 18:29:49.000000000 +0200
@@ -176,6 +176,10 @@
 	[NL80211_ATTR_WOWLAN_TRIGGERS] = { .type = NLA_NESTED },
 	[NL80211_ATTR_STA_PLINK_STATE] = { .type = NLA_U8 },
 	[NL80211_ATTR_SCHED_SCAN_INTERVAL] = { .type = NLA_U32 },
+	[NL80211_ATTR_SCAN_SUPP_RATES] = { .type = NLA_NESTED },
+	[NL80211_ATTR_TX_NO_CCK_RATE] = { .type = NLA_FLAG },
+	[NL80211_ATTR_PROBE_RESP] = { .type = NLA_BINARY,
+				      .len = IEEE80211_MAX_DATA_LEN },
 };
 
 /* policy for the key attributes */
@@ -2806,6 +2810,15 @@
 		    params.ssid_len > IEEE80211_MAX_SSID_LEN)
 			return -EINVAL;
 	}
+	if (info->attrs[NL80211_ATTR_PROBE_RESP]) {
+		if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP)
+			return -EOPNOTSUPP;
+
+		params.probe_resp =
+			nla_data(info->attrs[NL80211_ATTR_PROBE_RESP]);
+		params.probe_resp_len =
+			nla_len(info->attrs[NL80211_ATTR_PROBE_RESP]);
+	}
 
 	if (!rdev->ops->change_bss)
 		return -EOPNOTSUPP;
@@ -3332,7 +3345,6 @@
 	struct nlattr *attr;
 	struct wiphy *wiphy;
 	int err, tmp, n_ssids = 0, n_channels, i;
-	enum ieee80211_band band;
 	size_t ie_len;
 
 	if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))
@@ -3352,6 +3364,7 @@
 		if (!n_channels)
 			return -EINVAL;
 	} else {
+		enum ieee80211_band band;
 		n_channels = 0;
 
 		for (band = 0; band < IEEE80211_NUM_BANDS; band++)
@@ -3412,6 +3425,8 @@
 			i++;
 		}
 	} else {
+		enum ieee80211_band band;
+
 		/* all channels */
 		for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
 			int j;
@@ -3458,6 +3473,33 @@
 		       request->ie_len);
 	}
 
+	for (i = 0; i < IEEE80211_NUM_BANDS; i++)
+		if (wiphy->bands[i])
+			request->rates[i] =
+				(1 << wiphy->bands[i]->n_bitrates) - 1;
+
+	if (info->attrs[NL80211_ATTR_SCAN_SUPP_RATES]) {
+		nla_for_each_nested(attr,
+				    info->attrs[NL80211_ATTR_SCAN_SUPP_RATES],
+				    tmp) {
+			enum ieee80211_band band = nla_type(attr);
+
+			if (band < 0 || band > IEEE80211_NUM_BANDS) {
+				err = -EINVAL;
+				goto out_free;
+			}
+			err = ieee80211_get_ratemask(wiphy->bands[band],
+						     nla_data(attr),
+						     nla_len(attr),
+						     &request->rates[band]);
+			if (err)
+				goto out_free;
+		}
+	}
+
+	request->no_cck =
+		nla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);
+
 	request->dev = dev;
 	request->wiphy = &rdev->wiphy;
 
@@ -4318,25 +4360,12 @@
 			nla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);
 		struct ieee80211_supported_band *sband =
 			wiphy->bands[ibss.channel->band];
-		int i, j;
+		int err;
 
-		if (n_rates == 0)
-			return -EINVAL;
-
-		for (i = 0; i < n_rates; i++) {
-			int rate = (rates[i] & 0x7f) * 5;
-			bool found = false;
-
-			for (j = 0; j < sband->n_bitrates; j++) {
-				if (sband->bitrates[j].bitrate == rate) {
-					found = true;
-					ibss.basic_rates |= BIT(j);
-					break;
-				}
-			}
-			if (!found)
-				return -EINVAL;
-		}
+		err = ieee80211_get_ratemask(sband, rates, n_rates,
+					     &ibss.basic_rates);
+		if (err)
+			return err;
 	}
 
 	if (info->attrs[NL80211_ATTR_MCAST_RATE] &&
@@ -4877,6 +4906,7 @@
 	struct sk_buff *msg;
 	unsigned int wait = 0;
 	bool offchan;
+	bool no_cck;
 
 	if (!info->attrs[NL80211_ATTR_FRAME] ||
 	    !info->attrs[NL80211_ATTR_WIPHY_FREQ])
@@ -4913,6 +4943,8 @@
 
 	offchan = info->attrs[NL80211_ATTR_OFFCHANNEL_TX_OK];
 
+	no_cck = nla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);
+
 	freq = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]);
 	chan = rdev_freq_to_chan(rdev, freq, channel_type);
 	if (chan == NULL)
@@ -4933,7 +4965,7 @@
 				    channel_type_valid, wait,
 				    nla_data(info->attrs[NL80211_ATTR_FRAME]),
 				    nla_len(info->attrs[NL80211_ATTR_FRAME]),
-				    &cookie);
+				    no_cck, &cookie);
 	if (err)
 		goto free_msg;
 
diff -rNu a/net/wireless/reg.c b/net/wireless/reg.c
--- a/net/wireless/reg.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/wireless/reg.c	2011-12-20 18:29:49.000000000 +0200
@@ -33,7 +33,9 @@
  *
  */
 
+#ifndef pr_fmt
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#endif
 
 #include <linux/kernel.h>
 #include <linux/slab.h>
diff -rNu a/net/wireless/scan.c b/net/wireless/scan.c
--- a/net/wireless/scan.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/wireless/scan.c	2011-12-20 18:29:49.000000000 +0200
@@ -900,6 +900,10 @@
 			creq->n_ssids = 0;
 	}
 
+	for (i = 0; i < IEEE80211_NUM_BANDS; i++)
+		if (wiphy->bands[i])
+			creq->rates[i] = (1 << wiphy->bands[i]->n_bitrates) - 1;
+
 	rdev->scan_req = creq;
 	err = rdev->ops->scan(wiphy, dev, creq);
 	if (err) {
diff -rNu a/net/wireless/util.c b/net/wireless/util.c
--- a/net/wireless/util.c	2012-03-23 12:18:25.000000000 +0200
+++ b/net/wireless/util.c	2011-12-20 18:29:49.000000000 +0200
@@ -1006,3 +1006,41 @@
 
 	return -EBUSY;
 }
+
+int ieee80211_get_ratemask(struct ieee80211_supported_band *sband,
+			   const u8 *rates, unsigned int n_rates,
+			   u32 *mask)
+{
+	int i, j;
+
+	if (!sband)
+		return -EINVAL;
+
+	if (n_rates == 0 || n_rates > NL80211_MAX_SUPP_RATES)
+		return -EINVAL;
+
+	*mask = 0;
+
+	for (i = 0; i < n_rates; i++) {
+		int rate = (rates[i] & 0x7f) * 5;
+		bool found = false;
+
+		for (j = 0; j < sband->n_bitrates; j++) {
+			if (sband->bitrates[j].bitrate == rate) {
+				found = true;
+				*mask |= BIT(j);
+				break;
+			}
+		}
+		if (!found)
+			return -EINVAL;
+	}
+
+	/*
+	 * mask must have at least one bit set here since we
+	 * didn't accept a 0-length rates array nor allowed
+	 * entries in the array that didn't exist
+	 */
+
+	return 0;
+}
